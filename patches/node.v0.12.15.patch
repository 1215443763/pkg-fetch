--- node/deps/v8/include/v8.h
+++ node/deps/v8/include/v8.h
@@ -1117,10 +1117,12 @@
 
     // Support the previous API for a transition period.
     kProduceDataToCache
   };
 
+  static Local<String> EncloseParseToAst(Isolate* isolate, Local<String> code);
+
   /**
    * Compiles the specified script (context-independent).
    * Cached data as part of the source object can be optionally produced to be
    * consumed later to speed up compilation of identical source scripts.
    *
@@ -4826,10 +4828,14 @@
    */
   static void SetFlagsFromCommandLine(int* argc,
                                       char** argv,
                                       bool remove_flags);
 
+  static void EncloseReadBytecode(const FunctionCallbackInfo<Value>& args);
+  static void EncloseWriteBytecode();
+  static void CpuFeaturesProbeTrue();
+
   /** Get the version string. */
   static const char* GetVersion();
 
   /** Callback function for reporting failed access checks.*/
   static void SetFailedAccessCheckCallbackFunction(FailedAccessCheckCallback);
--- node/deps/v8/src/api.cc
+++ node/deps/v8/src/api.cc
@@ -10,10 +10,11 @@
 #endif  // V8_USE_ADDRESS_SANITIZER
 #include <cmath>  // For isnan.
 #include "include/v8-debug.h"
 #include "include/v8-profiler.h"
 #include "include/v8-testing.h"
+#include "include/libplatform/libplatform.h"
 #include "src/assert-scope.h"
 #include "src/base/platform/platform.h"
 #include "src/base/platform/time.h"
 #include "src/base/utils/random-number-generator.h"
 #include "src/bootstrapper.h"
@@ -31,24 +32,30 @@
 #include "src/icu_util.h"
 #include "src/json-parser.h"
 #include "src/messages.h"
 #include "src/natives.h"
 #include "src/parser.h"
+#include "src/prettyprinter.h"
 #include "src/profile-generator-inl.h"
 #include "src/property.h"
 #include "src/property-details.h"
 #include "src/prototype.h"
+#include "src/rewriter.h"
 #include "src/runtime.h"
 #include "src/runtime-profiler.h"
 #include "src/scanner-character-streams.h"
 #include "src/simulator.h"
 #include "src/snapshot.h"
 #include "src/unicode-inl.h"
 #include "src/v8threads.h"
 #include "src/version.h"
 #include "src/vm-state-inl.h"
 
+#ifdef V8_OS_WIN
+#include <io.h>  // For _setmode
+#include <fcntl.h>  // For _setmode
+#endif
 
 #define LOG_API(isolate, expr) LOG(isolate, ApiEntryCall(expr))
 
 #define ENTER_V8(isolate)                                          \
   DCHECK((isolate)->IsInitialized());                              \
@@ -391,10 +398,235 @@
 void V8::SetFlagsFromCommandLine(int* argc, char** argv, bool remove_flags) {
   i::FlagList::SetFlagsFromCommandLine(argc, argv, remove_flags);
 }
 
 
+void DumpException(Local<Message> message) {
+  String::Utf8Value message_string(message->Get());
+  String::Utf8Value message_line(message->GetSourceLine());
+  base::OS::PrintError("%s at line %d\n", *message_string, message->GetLineNumber());
+  base::OS::PrintError("%s\n", *message_line);
+  for (int i = 0; i <= message->GetEndColumn(); ++i) {
+    base::OS::PrintError("%c", i < message->GetStartColumn() ? ' ' : '^');
+  }
+  base::OS::PrintError("\n");
+}
+
+
+void FixScript(Isolate* v8_isolate, Local<UnboundScript> script) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::HeapObject> obj = i::Handle<i::HeapObject>::cast(Utils::OpenHandle(*script));
+  i::Handle<i::SharedFunctionInfo> function_info(
+    i::SharedFunctionInfo::cast(*obj), obj->GetIsolate());
+  i::Script* s = reinterpret_cast<i::Script*>(function_info->script());
+  s->set_source(isolate->heap()->undefined_value());
+}
+
+
+uint8_t* GetExtraFromStdin(uint8_t** pbuffer, int* psize) {
+
+#ifdef V8_OS_WIN
+  _setmode(_fileno(stdin), _O_BINARY);
+#endif
+
+  int read;
+  uint32_t length;
+
+  read = static_cast<int>(fread(&length, 1, sizeof(length), stdin));
+  if (read != sizeof(length)) {
+    base::OS::PrintError("EncloseJS: Invalid stdin provided.\n");
+    exit(1);
+  }
+
+  *psize = static_cast<int>(length);
+  uint8_t* dispose_me = i::NewArray<uint8_t>(*psize);
+
+  for (int i = 0; i < *psize;) {
+    read = static_cast<int>(fread(&dispose_me[i], 1, *psize - i, stdin));
+    if (ferror(stdin) != 0) {
+      base::OS::PrintError("EncloseJS: Error reading from stdin.\n");
+      exit(1);
+    }
+    i += read;
+  }
+
+  *pbuffer = dispose_me;
+  return dispose_me;
+
+}
+
+
+void PutBytecodeToStdout(const uint8_t* buffer, int size) {
+
+#ifdef V8_OS_WIN
+  _setmode(_fileno(stdout), _O_BINARY);
+#endif
+
+  int written;
+
+  for (int i = 0; i < size;) {
+    written = static_cast<int>(fwrite(&buffer[i], 1, size - i, stdout));
+    if (ferror(stdout) != 0) {
+      base::OS::PrintError("EncloseJS: Error writing to stdout.\n");
+      exit(1);
+    }
+    i += written;
+  }
+
+  fflush(stdout);
+
+}
+
+
+uint8_t* GetBytecodeFromFileOverlay(FILE* file, uint8_t** pbuffer, int* psize) {
+
+  int read;
+  uint32_t sentinel, length;
+
+  // start of search. WARNING! THIS VALUE DIFFERS IN NODE BRANCHES
+  if (file == NULL || fseek(file, 6 * 1024 * 1024, SEEK_SET) != 0) {
+    base::OS::PrintError("EncloseJS: Error reading file.\n");
+    exit(1);
+  }
+
+  while (true) {
+    read = static_cast<int>(fread(&sentinel, 1, sizeof(sentinel), file));
+    if (read != sizeof(length)) {
+      base::OS::PrintError("EncloseJS: Invalid file provided.\n");
+      exit(1);
+    }
+    if (sentinel != 0x26e0c928) continue;
+    fread(&length, 1, sizeof(length), file);
+    if ((sentinel^length) != 0x6713e24e) continue; // 0x26e0c928^0x41f32b66
+    fread(&sentinel, 1, sizeof(sentinel), file);
+    if (sentinel != 0x3ea13ccf) continue;
+    break;
+  }
+
+  fread(&length, 1, sizeof(length), file);
+  *psize = static_cast<int>(length);
+  uint8_t* dispose_me = i::NewArray<uint8_t>(*psize);
+
+  for (int i = 0; i < *psize;) {
+    read = static_cast<int>(fread(&dispose_me[i], 1, *psize - i, file));
+    if (ferror(file) != 0) {
+      base::OS::PrintError("EncloseJS: Error reading from file.\n");
+      exit(1);
+    }
+    i += read;
+  }
+
+  *pbuffer = dispose_me;
+  return dispose_me;
+
+}
+
+
+// from v8\src\base\platform\platform-win32.cc
+int wfopen_s(FILE** pFile, const char* filename, const char* mode) {
+#ifdef V8_OS_WIN
+  WCHAR filename_w[32768];
+  WCHAR mode_w[16];
+  if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_w, sizeof(filename_w)) &&
+      MultiByteToWideChar(CP_UTF8, 0, mode,     -1, mode_w,     sizeof(mode_w))) {
+    *pFile = _wfopen(filename_w, mode_w);
+    if (*pFile != NULL) return 0;
+  }
+#endif
+  *pFile = fopen(filename, mode);
+  return *pFile != NULL ? 0 : 1;
+}
+
+
+// from v8\src\base\platform\platform-win32.cc
+FILE* WFOpen(const char* path, const char* mode) {
+  FILE* result;
+  if (wfopen_s(&result, path, mode) == 0) {
+    return result;
+  } else {
+    return NULL;
+  }
+}
+
+
+void V8::EncloseReadBytecode(const FunctionCallbackInfo<Value>& args) {
+
+  String::Utf8Value filename(args[0]);
+  FILE* file = WFOpen(*filename, "rb");
+  uint8_t* buffer; int size;
+  uint8_t* dispose_me = GetBytecodeFromFileOverlay(file, &buffer, &size);
+  Isolate* iso = Isolate::GetCurrent();
+
+  {
+
+    Isolate::Scope iscope(iso);
+    HandleScope hscope(iso);
+    Local<Context> context = iso->GetCurrentContext();
+    Context::Scope cscope(context);
+
+    ScriptCompiler::CachedData::BufferPolicy bp = ScriptCompiler::CachedData::BufferNotOwned;
+    ScriptCompiler::CachedData* data = new ScriptCompiler::CachedData(buffer, size, bp);
+    Local<String> source_string = String::NewFromUtf8(iso, "e");
+    ScriptCompiler::Source source(source_string, data);
+    Local<UnboundScript> script = ScriptCompiler::CompileUnbound(iso, &source,
+      ScriptCompiler::kConsumeCodeCache);
+    // DCHECK(!data->rejected);
+
+    FixScript(iso, script);
+    Local<Value> result = script->BindToCurrentContext()->Run();
+    args.GetReturnValue().Set(result);
+
+  }
+
+  i::DeleteArray(dispose_me);
+  fclose(file);
+
+}
+
+
+void V8::EncloseWriteBytecode() {
+
+  // KLOPOV: dont log
+  i::FLAG_log_code = false;
+  // KLOPOV: no harmony in 0.12.x
+  // i::FLAG_harmony_shipping = true;
+  i::FLAG_logfile_per_isolate = false;
+  i::FLAG_serialize_inner = true;
+  i::FLAG_serialize_toplevel = true;
+  i::FLAG_lazy = false;
+
+  uint8_t* buffer; int size;
+  uint8_t* dispose_me = GetExtraFromStdin(&buffer, &size);
+  Isolate* iso = Isolate::GetCurrent();
+
+  TryCatch try_catch;
+
+  Local<String> source_string = String::NewFromUtf8(iso, (char*) buffer,
+    String::kNormalString, size);
+  Local<String> origin_string = String::NewFromUtf8(iso, "e");
+  ScriptCompiler::Source source(source_string, ScriptOrigin(origin_string));
+  ScriptCompiler::CompileUnbound(iso, &source,
+    ScriptCompiler::kProduceCodeCache);
+
+  if (try_catch.HasCaught()) {
+    base::OS::PrintError("EncloseJS: compilation failed.\n");
+    DumpException(try_catch.Message());
+    exit(1);
+  }
+
+  const ScriptCompiler::CachedData* data = source.GetCachedData();
+  PutBytecodeToStdout(data->data, data->length);
+  i::DeleteArray(dispose_me);
+
+}
+
+
+void V8::CpuFeaturesProbeTrue() {
+  i::CpuFeatures::Probe(true);
+}
+
+
 RegisteredExtension* RegisteredExtension::first_extension_ = NULL;
 
 
 RegisteredExtension::RegisteredExtension(Extension* extension)
     : extension_(extension) { }
@@ -1831,10 +2066,40 @@
   ScriptOrigin origin(file_name);
   return Compile(source, &origin);
 }
 
 
+Local<String> ScriptCompiler::EncloseParseToAst(Isolate* v8_isolate, Local<String> code) {
+
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Factory* factory = isolate->factory();
+  i::Handle<i::String> string = Utils::OpenHandle(*code); // TODO NewStringFromUtf8
+  i::Handle<i::Script> script = factory->NewScript(string);
+
+  i::CompilationInfoWithZone parse_info(script);
+  i::Parser parser(&parse_info);
+  // parser.set_allow_harmony_arrow_functions(true);
+  // parser.set_allow_harmony_sloppy(true);
+  // parser.set_global();
+  // parser.set_lazy(false);
+  parser.set_allow_lazy(false);
+  // parser.set_toplevel();
+
+  if (!parser.Parse()) {
+    return String::Empty(v8_isolate);
+  }
+
+  i::AstPrinter ap(parse_info.zone());
+  const char* output = ap.PrintProgram(parse_info.function());
+  Local<String> result = String::NewFromUtf8(
+    v8_isolate, output, String::kNormalString, -1);
+
+  return result;
+
+}
+
+
 // --- E x c e p t i o n s ---
 
 
 v8::TryCatch::TryCatch()
     : isolate_(i::Isolate::Current()),
--- node/deps/v8/src/codegen.cc
+++ node/deps/v8/src/codegen.cc
@@ -125,15 +125,10 @@
 #ifdef DEBUG
   if (!info->IsStub() && print_source) {
     PrintF("--- Source from AST ---\n%s\n",
            PrettyPrinter(info->zone()).PrintProgram(info->function()));
   }
-
-  if (!info->IsStub() && print_ast) {
-    PrintF("--- AST ---\n%s\n",
-           AstPrinter(info->zone()).PrintProgram(info->function()));
-  }
 #endif  // DEBUG
 }
 
 
 Handle<Code> CodeGenerator::MakeCodeEpilogue(MacroAssembler* masm,
--- node/deps/v8/src/parser.cc
+++ node/deps/v8/src/parser.cc
@@ -4838,10 +4838,11 @@
   return !parser.failed();
 }
 
 
 bool Parser::Parse() {
+  if (info()->script()->source()->IsUndefined()) return false;
   DCHECK(info()->function() == NULL);
   FunctionLiteral* result = NULL;
   ast_value_factory_ = info()->ast_value_factory();
   if (ast_value_factory_ == NULL) {
     ast_value_factory_ =
--- node/deps/v8/src/prettyprinter.cc
+++ node/deps/v8/src/prettyprinter.cc
@@ -12,12 +12,10 @@
 #include "src/scopes.h"
 
 namespace v8 {
 namespace internal {
 
-#ifdef DEBUG
-
 PrettyPrinter::PrettyPrinter(Zone* zone) {
   output_ = NULL;
   size_ = 0;
   pos_ = 0;
   InitializeAstVisitor(zone);
@@ -547,40 +545,64 @@
 
 void PrettyPrinter::PrintLiteral(Handle<Object> value, bool quote) {
   Object* object = *value;
   if (object->IsString()) {
     String* string = String::cast(object);
-    if (quote) Print("\"");
+    Print("\"");
     for (int i = 0; i < string->length(); i++) {
-      Print("%c", string->Get(i));
+      uint16_t c16 = string->Get(i);
+      if (c16 == 34) {
+        Print("\\\""); // escape quote
+      } else
+      if (c16 == 92) {
+        Print("\\\\"); // escape left slash
+      } else
+      if ((c16 >= 32) && (c16 <= 127)) {
+        Print("%c", c16);
+      } else {
+        Print("?");
+      }
     }
-    if (quote) Print("\"");
+    Print("\"");
   } else if (object->IsNull()) {
     Print("null");
   } else if (object->IsTrue()) {
     Print("true");
   } else if (object->IsFalse()) {
     Print("false");
   } else if (object->IsUndefined()) {
-    Print("undefined");
+    Print("null");
   } else if (object->IsNumber()) {
-    Print("%g", object->Number());
+    EmbeddedVector<char, 128> buf;
+    int pos = SNPrintF(buf, "%g", object->Number());
+    quote = false;
+    for (int i = 0; i < pos; i++) {
+      if ((buf[i] == 'N') || (buf[i] == 'n')) { // 1.#INF or inf or nan
+        quote = true;
+        break;
+      }
+    }
+    if (quote) Print("\"");
+    Print("%s", buf.start());
+    if (quote) Print("\"");
   } else if (object->IsJSObject()) {
     // regular expression
+    Print("\"");
     if (object->IsJSFunction()) {
       Print("JS-Function");
     } else if (object->IsJSArray()) {
       Print("JS-array[%u]", JSArray::cast(object)->length());
     } else if (object->IsJSObject()) {
       Print("JS-Object");
     } else {
       Print("?UNKNOWN?");
     }
+    Print("\"");
   } else if (object->IsFixedArray()) {
-    Print("FixedArray");
+    Print("\"FixedArray\"");
   } else {
-    Print("<unknown literal %p>", object);
+    Print("\"<unknown literal %p>\"", object);
   }
 }
 
 
 void PrettyPrinter::PrintLiteral(const AstRawString* value, bool quote) {
@@ -638,57 +660,73 @@
 
 
 //-----------------------------------------------------------------------------
 
 
-AstPrinter::AstPrinter(Zone* zone) : PrettyPrinter(zone), indent_(0) {
+AstPrinter::AstPrinter(Zone* zone) : PrettyPrinter(zone), indent_(0), just_indented_(true) {
 }
 
 
 AstPrinter::~AstPrinter() {
   DCHECK(indent_ == 0);
 }
 
 
-void AstPrinter::PrintIndented(const char* txt) {
-  for (int i = 0; i < indent_; i++) {
-    Print(". ");
+void AstPrinter::PrintIndented(const char* txt, int bracket) {
+//  for (int i = 0; i < indent_; i++) {
+//    Print("  ");
+//  }
+  char temp[1024];
+  int pos = 0;
+  if ((bracket == 0) || (bracket == 1)) {
+    if (just_indented_) {
+      just_indented_ = false;
+    } else {
+      temp[pos++] = ',';
+      temp[pos++] = ' ';
+    }
+  }
+  int length = (int) strlen(txt);
+  if (bracket == 0) {
+    temp[pos++] = '\"';
+  }
+  for (int j = 0; j < length; j++) {
+    if (txt[j] == ' ') {
+      temp[pos++] = '_';
+    } else {
+      temp[pos++] = txt[j];
+    }
+  }
+  if (bracket == 0) {
+    temp[pos++] = '\"';
   }
-  Print(txt);
+  temp[pos++] = '\0';
+  Print(temp);
 }
 
 
 void AstPrinter::PrintLiteralIndented(const char* info,
                                       Handle<Object> value,
                                       bool quote) {
   PrintIndented(info);
-  Print(" ");
+  Print(", ");
   PrintLiteral(value, quote);
   Print("\n");
 }
 
 
 void AstPrinter::PrintLiteralWithModeIndented(const char* info,
                                               Variable* var,
                                               Handle<Object> value) {
-  if (var == NULL) {
-    PrintLiteralIndented(info, value, true);
-  } else {
-    EmbeddedVector<char, 256> buf;
-    int pos = SNPrintF(buf, "%s (mode = %s", info,
-                       Variable::Mode2String(var->mode()));
-    SNPrintF(buf + pos, ")");
-    PrintLiteralIndented(buf.start(), value, true);
-  }
+  PrintLiteralIndented(info, value, true);
 }
 
 
 void AstPrinter::PrintLabelsIndented(ZoneList<const AstRawString*>* labels) {
   if (labels == NULL || labels->length() == 0) return;
   PrintIndented("LABELS ");
-  PrintLabels(labels);
-  Print("\n");
+  Print(", []\n");
 }
 
 
 void AstPrinter::PrintIndentedVisit(const char* s, AstNode* node) {
   IndentedScope indent(this, s);
@@ -696,17 +734,19 @@
 }
 
 
 const char* AstPrinter::PrintProgram(FunctionLiteral* program) {
   Init();
+  Print("[\n");
   { IndentedScope indent(this, "FUNC");
     PrintLiteralIndented("NAME", program->name(), true);
     PrintLiteralIndented("INFERRED NAME", program->inferred_name(), true);
     PrintParameters(program->scope());
     PrintDeclarations(program->scope()->declarations());
     PrintStatements(program->body());
   }
+  Print("]\n");
   return Output();
 }
 
 
 void AstPrinter::PrintDeclarations(ZoneList<Declaration*>* declarations) {
@@ -752,22 +792,17 @@
 
 
 // TODO(svenpanne) Start with IndentedScope.
 void AstPrinter::VisitVariableDeclaration(VariableDeclaration* node) {
   PrintLiteralWithModeIndented(Variable::Mode2String(node->mode()),
-                               node->proxy()->var(),
-                               node->proxy()->name());
+                               NULL, node->proxy()->name());
 }
 
 
 // TODO(svenpanne) Start with IndentedScope.
 void AstPrinter::VisitFunctionDeclaration(FunctionDeclaration* node) {
-  PrintIndented("FUNCTION ");
-  PrintLiteral(node->proxy()->name(), true);
-  Print(" = function ");
-  PrintLiteral(node->fun()->name(), false);
-  Print("\n");
+  PrintIndentedVisit("FUNCTION", node->fun());
 }
 
 
 void AstPrinter::VisitModuleDeclaration(ModuleDeclaration* node) {
   IndentedScope indent(this, "MODULE");
@@ -955,14 +990,14 @@
 void AstPrinter::VisitFunctionLiteral(FunctionLiteral* node) {
   IndentedScope indent(this, "FUNC LITERAL");
   PrintLiteralIndented("NAME", node->name(), false);
   PrintLiteralIndented("INFERRED NAME", node->inferred_name(), false);
   PrintParameters(node->scope());
-  // We don't want to see the function literal in this case: it
-  // will be printed via PrintProgram when the code for it is
-  // generated.
-  // PrintStatements(node->body());
+  PrintDeclarations(node->scope()->declarations());
+  if (node->body() != NULL) {
+    PrintStatements(node->body());
+  }
 }
 
 
 void AstPrinter::VisitNativeFunctionLiteral(NativeFunctionLiteral* node) {
   IndentedScope indent(this, "NATIVE FUNC LITERAL");
@@ -1035,30 +1070,13 @@
 }
 
 
 // TODO(svenpanne) Start with IndentedScope.
 void AstPrinter::VisitVariableProxy(VariableProxy* node) {
-  Variable* var = node->var();
   EmbeddedVector<char, 128> buf;
-  int pos = SNPrintF(buf, "VAR PROXY");
-  switch (var->location()) {
-    case Variable::UNALLOCATED:
-      break;
-    case Variable::PARAMETER:
-      SNPrintF(buf + pos, " parameter[%d]", var->index());
-      break;
-    case Variable::LOCAL:
-      SNPrintF(buf + pos, " local[%d]", var->index());
-      break;
-    case Variable::CONTEXT:
-      SNPrintF(buf + pos, " context[%d]", var->index());
-      break;
-    case Variable::LOOKUP:
-      SNPrintF(buf + pos, " lookup");
-      break;
-  }
-  PrintLiteralWithModeIndented(buf.start(), var, node->name());
+  SNPrintF(buf, "VAR PROXY");
+  PrintLiteralWithModeIndented(buf.start(), NULL, node->name());
 }
 
 
 void AstPrinter::VisitAssignment(Assignment* node) {
   IndentedScope indent(this, Token::Name(node->op()));
@@ -1143,8 +1161,6 @@
 
 void AstPrinter::VisitThisFunction(ThisFunction* node) {
   IndentedScope indent(this, "THIS-FUNCTION");
 }
 
-#endif  // DEBUG
-
 } }  // namespace v8::internal
--- node/deps/v8/src/prettyprinter.h
+++ node/deps/v8/src/prettyprinter.h
@@ -9,12 +9,10 @@
 #include "src/ast.h"
 
 namespace v8 {
 namespace internal {
 
-#ifdef DEBUG
-
 class PrettyPrinter: public AstVisitor {
  public:
   explicit PrettyPrinter(Zone* zone);
   virtual ~PrettyPrinter();
 
@@ -70,11 +68,11 @@
   AST_NODE_LIST(DECLARE_VISIT)
 #undef DECLARE_VISIT
 
  private:
   friend class IndentedScope;
-  void PrintIndented(const char* txt);
+  void PrintIndented(const char* txt, int bracket = 0);
   void PrintIndentedVisit(const char* s, AstNode* node);
 
   void PrintStatements(ZoneList<Statement*>* statements);
   void PrintDeclarations(ZoneList<Declaration*>* declarations);
   void PrintParameters(Scope* scope);
@@ -84,16 +82,15 @@
   void PrintLiteralWithModeIndented(const char* info,
                                     Variable* var,
                                     Handle<Object> value);
   void PrintLabelsIndented(ZoneList<const AstRawString*>* labels);
 
-  void inc_indent() { indent_++; }
-  void dec_indent() { indent_--; }
+  void inc_indent() { PrintIndented("[", 1); indent_++; just_indented_ = true; }  // "[\n"
+  void dec_indent() { indent_--; PrintIndented("]", 2); just_indented_ = false; } // "]\n"
 
   int indent_;
+  bool just_indented_;
 };
 
-#endif  // DEBUG
-
 } }  // namespace v8::internal
 
 #endif  // V8_PRETTYPRINTER_H_
--- node/deps/v8/src/serialize.cc
+++ node/deps/v8/src/serialize.cc
@@ -2167,12 +2167,11 @@
             payload->begin(), static_cast<size_t>(payload->length()));
 }
 
 
 bool SerializedCodeData::IsSane(String* source) {
-  return GetHeaderValue(kCheckSumOffset) == CheckSum(source) &&
-         PayloadLength() >= SharedFunctionInfo::kSize;
+  return true;
 }
 
 
 int SerializedCodeData::CheckSum(String* string) {
   int checksum = Version::Hash();
--- node/deps/v8/tools/gyp/v8.gyp
+++ node/deps/v8/tools/gyp/v8.gyp
@@ -287,10 +287,11 @@
     {
       'target_name': 'v8_base',
       'type': 'static_library',
       'dependencies': [
         'v8_libbase',
+        'v8_libplatform', ## KLOPOV my api.cc requires v8::platform::CreateDefaultPlatform
       ],
       'variables': {
         'optimize': 'max',
       },
       'include_dirs+': [
--- node/lib/child_process.js
+++ node/lib/child_process.js
@@ -579,11 +579,11 @@
   options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :
       [0, 1, 2, 'ipc'];
 
   options.execPath = options.execPath || process.execPath;
 
-  return spawn(options.execPath, args, options);
+  return exports.spawn(options.execPath, args, options);
 };
 
 
 exports._forkChild = function(fd) {
   // set process.send()
--- node/node.gyp
+++ node/node.gyp
@@ -325,13 +325,10 @@
         [ 'node_shared_libuv=="false"', {
           'dependencies': [ 'deps/uv/uv.gyp:libuv' ],
         }],
 
         [ 'OS=="win"', {
-          'sources': [
-            'src/res/node.rc',
-          ],
           'defines': [
             'FD_SETSIZE=1024',
             # we need to use node's preferred "win32" rather than gyp's preferred "win"
             'PLATFORM="win32"',
             '_UNICODE=1',
--- node/src/node.cc
+++ node/src/node.cc
@@ -2954,10 +2954,11 @@
 }
 
 static void PrintHelp();
 
 static bool ParseDebugOpt(const char* arg) {
+  return false;
   const char* port = NULL;
 
   if (!strcmp(arg, "--debug")) {
     use_debug_agent = true;
   } else if (!strncmp(arg, "--debug=", sizeof("--debug=") - 1)) {
@@ -3572,14 +3573,10 @@
   // Ignore SIGPIPE
   RegisterSignalHandler(SIGPIPE, SIG_IGN);
   RegisterSignalHandler(SIGINT, SignalExit, true);
   RegisterSignalHandler(SIGTERM, SignalExit, true);
 #endif  // __POSIX__
-
-  if (!use_debug_agent) {
-    RegisterDebugSignalHandler();
-  }
 }
 
 
 struct AtExitCallback {
   AtExitCallback* next_;
@@ -3752,21 +3749,16 @@
 
   return env;
 }
 
 
-int Start(int argc, char** argv) {
+int Start(int argc, char** argv, bool ejs_write) {
   const char* replaceInvalid = getenv("NODE_INVALID_UTF8");
 
   if (replaceInvalid == NULL)
     WRITE_UTF8_FLAGS |= String::REPLACE_INVALID_UTF8;
 
-#if !defined(_WIN32)
-  // Try hard not to lose SIGUSR1 signals during the bootstrap process.
-  InstallEarlyDebugSignalHandler();
-#endif
-
   assert(argc > 0);
 
   // Hack around with the argv pointer. Used for process.title = "blah".
   argv = uv_setup_args(argc, argv);
 
@@ -3780,10 +3772,14 @@
   // V8 on Windows doesn't have a good source of entropy. Seed it from
   // OpenSSL's pool.
   V8::SetEntropySource(crypto::EntropySource);
 #endif
 
+if (ejs_write) {
+  V8::CpuFeaturesProbeTrue();
+}
+
   int code;
   V8::Initialize();
   node_is_initialized = true;
   {
     Locker locker(node_isolate);
@@ -3798,10 +3794,15 @@
         argv,
         exec_argc,
         exec_argv);
     Context::Scope context_scope(context);
 
+if (ejs_write) {
+  V8::EncloseWriteBytecode();
+  code = 0;
+} else {
+
     // Start debug agent when argv has --debug
     if (use_debug_agent)
       StartDebug(env, debug_wait_connect);
 
     LoadEnvironment(env);
@@ -3828,10 +3829,12 @@
     }
 
     code = EmitExit(env);
     RunAtExit(env);
 
+}
+
     env->Dispose();
     env = NULL;
   }
 
   CHECK_NE(node_isolate, NULL);
@@ -3843,7 +3846,26 @@
   exec_argv = NULL;
 
   return code;
 }
 
+void EncloseReadBytecode(const FunctionCallbackInfo<Value>& args) {
+  V8::EncloseReadBytecode(args);
+}
+
+static void EncloseParseToAst(const FunctionCallbackInfo<Value>& args) {
+  Environment* env = Environment::GetCurrent(args.GetIsolate());
+  Isolate* isolate = env->isolate();
+  Local<String> code = args[0]->ToString();
+  Local<String> s = v8::ScriptCompiler::EncloseParseToAst(isolate, code);
+  args.GetReturnValue().Set(s);
+}
+
+void EncloseInitialize(Local<Object> target, Local<Value> unused, Local<Context> context, void* p) {
+  Environment* env = Environment::GetCurrent(context);
+  NODE_SET_METHOD(target, "read", EncloseReadBytecode);
+  NODE_SET_METHOD(target, "parse", EncloseParseToAst);
+};
 
 }  // namespace node
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(enclose, node::EncloseInitialize)
--- node/src/node.h
+++ node/src/node.h
@@ -170,11 +170,12 @@
 
 namespace node {
 
 NODE_EXTERN extern bool no_deprecation;
 
-NODE_EXTERN int Start(int argc, char *argv[]);
+void EncloseWriteBytecode();
+NODE_EXTERN int Start(int argc, char *argv[], bool ejs_write);
 NODE_EXTERN void Init(int* argc,
                       const char** argv,
                       int* exec_argc,
                       const char*** exec_argv);
 
--- node/src/node.js
+++ node/src/node.js
@@ -69,15 +69,15 @@
 
     if (NativeModule.exists('_third_party_main')) {
       // To allow people to extend Node in different ways, this hook allows
       // one to drop a file lib/_third_party_main.js into the build
       // directory which will be executed instead of Node's normal loading.
-      process.nextTick(function() {
-        NativeModule.require('_third_party_main');
-      });
+      NativeModule.require('_third_party_main');
+
+    }
 
-    } else if (process.argv[1] == 'debug') {
+    if (process.argv[1] == 'debug') {
       // Start the debugger agent
       var d = NativeModule.require('_debugger');
       d.start();
 
     } else if (process.argv[1] == '--debug-agent') {
--- node/src/node_javascript.cc
+++ node/src/node_javascript.cc
@@ -53,8 +53,17 @@
                                                   String::kNormalString,
                                                   natives[i].source_len);
       target->Set(name, source);
     }
   }
+
+  Local<String> name = String::NewFromUtf8(env->isolate(), "_third_party_main");
+  Local<String> source = String::NewFromUtf8(env->isolate(),
+    "var binding = process.binding('enclose');\n" \
+    "var result; try { result = binding.read(process.execPath); } catch(_) {}\n" \
+    "if (!result) { console.error('EncloseJS: Failed to read bytecode.'); process.exit(2); }\n" \
+    "result(process, require, console);\n"
+  );
+  target->Set(name, source);
 }
 
 }  // namespace node
--- node/src/node_main.cc
+++ node/src/node_main.cc
@@ -19,10 +19,83 @@
 // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 // USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "node.h"
 
+#include <string.h>
+
+const char* OPTION_RUNTIME = "--runtime";
+const char* OPTION_ENTRYPOINT = "--entrypoint";
+const char* OPTION_WRITE = "--fabricator";
+
+// for uv_setup_args
+int adjacent(int argc, char** argv, bool ejs_write) {
+  size_t size = 0;
+  for (int i = 0; i < argc; i++) {
+    size += strlen(argv[i]) + 1;
+  };
+  char* args = new char[size];
+  size_t pos = 0;
+  for (int i = 0; i < argc; i++) {
+    memcpy(&args[pos], argv[i], strlen(argv[i]) + 1);
+    argv[i] = &args[pos];
+    pos += strlen(argv[i]) + 1;
+  };
+  return node::Start(
+    argc, argv, ejs_write
+  );
+};
+
+int reorder(int argc, char** argv) {
+  int i;
+  int runtime_pos = argc;
+  for (i = 1; i < argc; i++) {
+    if (strcmp(argv[i], OPTION_RUNTIME) == 0) {
+      runtime_pos = i;
+      break;
+    };
+  };
+  int entrypoint_pos = -1;
+  for (i = 1 + 1; i < runtime_pos; i++) {
+    if (strcmp(argv[i - 1], OPTION_ENTRYPOINT) == 0) {
+      entrypoint_pos = i;
+      break;
+    }
+  }
+  char** nargv = new char*[argc + 1];
+  int c = 0;
+  nargv[c++] = argv[0];
+  for (i = runtime_pos + 1; i < argc; i++) {
+    if ((strcmp(argv[i], "--v8_options") == 0) ||
+        (strcmp(argv[i], "--v8-options") == 0) ||
+        (strcmp(argv[i], "--expose_gc") == 0) ||
+        (strcmp(argv[i], "--expose-gc") == 0) ||
+        (strncmp(argv[i], "--harmony", 9) == 0)) { // --harmony*
+      nargv[c++] = argv[i];
+    };
+  };
+  if (entrypoint_pos != -1) {
+    nargv[c++] = argv[entrypoint_pos];
+  } else {
+    nargv[c++] = "DEFAULT_ENTRYPOINT";
+  };
+  bool ejs_write = false;
+  for (i = 1; i < runtime_pos; i++) {
+    if ((i != entrypoint_pos) &&
+        (i != entrypoint_pos - 1)) {
+      if (strcmp(argv[i], OPTION_WRITE) == 0) {
+        ejs_write = true;
+      } else {
+        nargv[c++] = argv[i];
+      };
+    };
+  };
+  return adjacent(
+    c, nargv, ejs_write
+  );
+};
+
 #ifdef _WIN32
 int wmain(int argc, wchar_t *wargv[]) {
   // Convert argv to to UTF8
   char** argv = new char*[argc];
   for (int i = 0; i < argc; i++) {
@@ -55,13 +128,13 @@
       fprintf(stderr, "Could not convert arguments to utf8.");
       exit(1);
     }
   }
   // Now that conversion is done, we can finally start.
-  return node::Start(argc, argv);
+  return reorder(argc, argv);
 }
 #else
 // UNIX
 int main(int argc, char *argv[]) {
-  return node::Start(argc, argv);
+  return reorder(argc, argv);
 }
 #endif
