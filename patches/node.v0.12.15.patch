--- node/deps/v8/include/v8.h
+++ node/deps/v8/include/v8.h
@@ -4826,10 +4826,14 @@
    */
   static void SetFlagsFromCommandLine(int* argc,
                                       char** argv,
                                       bool remove_flags);
 
+  static void PkgReadBytecode(const FunctionCallbackInfo<Value>& args);
+  static void PkgWriteBytecode();
+  static void CpuFeaturesProbeTrue();
+
   /** Get the version string. */
   static const char* GetVersion();
 
   /** Callback function for reporting failed access checks.*/
   static void SetFailedAccessCheckCallbackFunction(FailedAccessCheckCallback);
--- node/deps/v8/src/api.cc
+++ node/deps/v8/src/api.cc
@@ -10,10 +10,11 @@
 #endif  // V8_USE_ADDRESS_SANITIZER
 #include <cmath>  // For isnan.
 #include "include/v8-debug.h"
 #include "include/v8-profiler.h"
 #include "include/v8-testing.h"
+#include "include/libplatform/libplatform.h"
 #include "src/assert-scope.h"
 #include "src/base/platform/platform.h"
 #include "src/base/platform/time.h"
 #include "src/base/utils/random-number-generator.h"
 #include "src/bootstrapper.h"
@@ -45,10 +46,14 @@
 #include "src/unicode-inl.h"
 #include "src/v8threads.h"
 #include "src/version.h"
 #include "src/vm-state-inl.h"
 
+#ifdef V8_OS_WIN
+#include <io.h>  // For _setmode
+#include <fcntl.h>  // For _setmode
+#endif
 
 #define LOG_API(isolate, expr) LOG(isolate, ApiEntryCall(expr))
 
 #define ENTER_V8(isolate)                                          \
   DCHECK((isolate)->IsInitialized());                              \
@@ -391,10 +396,235 @@
 void V8::SetFlagsFromCommandLine(int* argc, char** argv, bool remove_flags) {
   i::FlagList::SetFlagsFromCommandLine(argc, argv, remove_flags);
 }
 
 
+void DumpException(Local<Message> message) {
+  String::Utf8Value message_string(message->Get());
+  String::Utf8Value message_line(message->GetSourceLine());
+  base::OS::PrintError("%s at line %d\n", *message_string, message->GetLineNumber());
+  base::OS::PrintError("%s\n", *message_line);
+  for (int i = 0; i <= message->GetEndColumn(); ++i) {
+    base::OS::PrintError("%c", i < message->GetStartColumn() ? ' ' : '^');
+  }
+  base::OS::PrintError("\n");
+}
+
+
+void FixScript(Isolate* v8_isolate, Local<UnboundScript> script) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::HeapObject> obj = i::Handle<i::HeapObject>::cast(Utils::OpenHandle(*script));
+  i::Handle<i::SharedFunctionInfo> function_info(
+    i::SharedFunctionInfo::cast(*obj), obj->GetIsolate());
+  i::Script* s = reinterpret_cast<i::Script*>(function_info->script());
+  s->set_source(isolate->heap()->undefined_value());
+}
+
+
+uint8_t* GetExtraFromStdin(uint8_t** pbuffer, int* psize) {
+
+#ifdef V8_OS_WIN
+  _setmode(_fileno(stdin), _O_BINARY);
+#endif
+
+  int read;
+  uint32_t length;
+
+  read = static_cast<int>(fread(&length, 1, sizeof(length), stdin));
+  if (read != sizeof(length)) {
+    base::OS::PrintError("Pkg: Invalid stdin provided.\n");
+    exit(1);
+  }
+
+  *psize = static_cast<int>(length);
+  uint8_t* dispose_me = i::NewArray<uint8_t>(*psize);
+
+  for (int i = 0; i < *psize;) {
+    read = static_cast<int>(fread(&dispose_me[i], 1, *psize - i, stdin));
+    if (ferror(stdin) != 0) {
+      base::OS::PrintError("Pkg: Error reading from stdin.\n");
+      exit(1);
+    }
+    i += read;
+  }
+
+  *pbuffer = dispose_me;
+  return dispose_me;
+
+}
+
+
+void PutBytecodeToStdout(const uint8_t* buffer, int size) {
+
+#ifdef V8_OS_WIN
+  _setmode(_fileno(stdout), _O_BINARY);
+#endif
+
+  int written;
+
+  for (int i = 0; i < size;) {
+    written = static_cast<int>(fwrite(&buffer[i], 1, size - i, stdout));
+    if (ferror(stdout) != 0) {
+      base::OS::PrintError("Pkg: Error writing to stdout.\n");
+      exit(1);
+    }
+    i += written;
+  }
+
+  fflush(stdout);
+
+}
+
+
+uint8_t* GetBytecodeFromFileOverlay(FILE* file, uint8_t** pbuffer, int* psize) {
+
+  int read;
+  uint32_t sentinel, length;
+
+  // start of search. WARNING! THIS VALUE DIFFERS IN NODE BRANCHES
+  if (file == NULL || fseek(file, 6 * 1024 * 1024, SEEK_SET) != 0) {
+    base::OS::PrintError("Pkg: Error reading file.\n");
+    exit(1);
+  }
+
+  while (true) {
+    read = static_cast<int>(fread(&sentinel, 1, sizeof(sentinel), file));
+    if (read != sizeof(length)) {
+      base::OS::PrintError("Pkg: Invalid file provided.\n");
+      exit(1);
+    }
+    if (sentinel != 0x26e0c928) continue;
+    fread(&length, 1, sizeof(length), file);
+    if ((sentinel^length) != 0x6713e24e) continue; // 0x26e0c928^0x41f32b66
+    fread(&sentinel, 1, sizeof(sentinel), file);
+    if (sentinel != 0x3ea13ccf) continue;
+    break;
+  }
+
+  fread(&length, 1, sizeof(length), file);
+  *psize = static_cast<int>(length);
+  uint8_t* dispose_me = i::NewArray<uint8_t>(*psize);
+
+  for (int i = 0; i < *psize;) {
+    read = static_cast<int>(fread(&dispose_me[i], 1, *psize - i, file));
+    if (ferror(file) != 0) {
+      base::OS::PrintError("Pkg: Error reading from file.\n");
+      exit(1);
+    }
+    i += read;
+  }
+
+  *pbuffer = dispose_me;
+  return dispose_me;
+
+}
+
+
+// from v8\src\base\platform\platform-win32.cc
+int wfopen_s(FILE** pFile, const char* filename, const char* mode) {
+#ifdef V8_OS_WIN
+  WCHAR filename_w[32768];
+  WCHAR mode_w[16];
+  if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_w, sizeof(filename_w)) &&
+      MultiByteToWideChar(CP_UTF8, 0, mode,     -1, mode_w,     sizeof(mode_w))) {
+    *pFile = _wfopen(filename_w, mode_w);
+    if (*pFile != NULL) return 0;
+  }
+#endif
+  *pFile = fopen(filename, mode);
+  return *pFile != NULL ? 0 : 1;
+}
+
+
+// from v8\src\base\platform\platform-win32.cc
+FILE* WFOpen(const char* path, const char* mode) {
+  FILE* result;
+  if (wfopen_s(&result, path, mode) == 0) {
+    return result;
+  } else {
+    return NULL;
+  }
+}
+
+
+void V8::PkgReadBytecode(const FunctionCallbackInfo<Value>& args) {
+
+  String::Utf8Value filename(args[0]);
+  FILE* file = WFOpen(*filename, "rb");
+  uint8_t* buffer; int size;
+  uint8_t* dispose_me = GetBytecodeFromFileOverlay(file, &buffer, &size);
+  Isolate* iso = Isolate::GetCurrent();
+
+  {
+
+    Isolate::Scope iscope(iso);
+    HandleScope hscope(iso);
+    Local<Context> context = iso->GetCurrentContext();
+    Context::Scope cscope(context);
+
+    ScriptCompiler::CachedData::BufferPolicy bp = ScriptCompiler::CachedData::BufferNotOwned;
+    ScriptCompiler::CachedData* data = new ScriptCompiler::CachedData(buffer, size, bp);
+    Local<String> source_string = String::NewFromUtf8(iso, "e");
+    ScriptCompiler::Source source(source_string, data);
+    Local<UnboundScript> script = ScriptCompiler::CompileUnbound(iso, &source,
+      ScriptCompiler::kConsumeCodeCache);
+    // DCHECK(!data->rejected);
+
+    FixScript(iso, script);
+    Local<Value> result = script->BindToCurrentContext()->Run();
+    args.GetReturnValue().Set(result);
+
+  }
+
+  i::DeleteArray(dispose_me);
+  fclose(file);
+
+}
+
+
+void V8::PkgWriteBytecode() {
+
+  // KLOPOV: dont log
+  i::FLAG_log_code = false;
+  // KLOPOV: no harmony in 0.12.x
+  // i::FLAG_harmony_shipping = true;
+  i::FLAG_logfile_per_isolate = false;
+  i::FLAG_serialize_inner = true;
+  i::FLAG_serialize_toplevel = true;
+  i::FLAG_lazy = false;
+
+  uint8_t* buffer; int size;
+  uint8_t* dispose_me = GetExtraFromStdin(&buffer, &size);
+  Isolate* iso = Isolate::GetCurrent();
+
+  TryCatch try_catch;
+
+  Local<String> source_string = String::NewFromUtf8(iso, (char*) buffer,
+    String::kNormalString, size);
+  Local<String> origin_string = String::NewFromUtf8(iso, "e");
+  ScriptCompiler::Source source(source_string, ScriptOrigin(origin_string));
+  ScriptCompiler::CompileUnbound(iso, &source,
+    ScriptCompiler::kProduceCodeCache);
+
+  if (try_catch.HasCaught()) {
+    base::OS::PrintError("Pkg: compilation failed.\n");
+    DumpException(try_catch.Message());
+    exit(1);
+  }
+
+  const ScriptCompiler::CachedData* data = source.GetCachedData();
+  PutBytecodeToStdout(data->data, data->length);
+  i::DeleteArray(dispose_me);
+
+}
+
+
+void V8::CpuFeaturesProbeTrue() {
+  i::CpuFeatures::Probe(true);
+}
+
+
 RegisteredExtension* RegisteredExtension::first_extension_ = NULL;
 
 
 RegisteredExtension::RegisteredExtension(Extension* extension)
     : extension_(extension) { }
--- node/deps/v8/src/parser.cc
+++ node/deps/v8/src/parser.cc
@@ -4838,10 +4838,11 @@
   return !parser.failed();
 }
 
 
 bool Parser::Parse() {
+  if (info()->script()->source()->IsUndefined()) return false;
   DCHECK(info()->function() == NULL);
   FunctionLiteral* result = NULL;
   ast_value_factory_ = info()->ast_value_factory();
   if (ast_value_factory_ == NULL) {
     ast_value_factory_ =
--- node/deps/v8/src/serialize.cc
+++ node/deps/v8/src/serialize.cc
@@ -2167,12 +2167,11 @@
             payload->begin(), static_cast<size_t>(payload->length()));
 }
 
 
 bool SerializedCodeData::IsSane(String* source) {
-  return GetHeaderValue(kCheckSumOffset) == CheckSum(source) &&
-         PayloadLength() >= SharedFunctionInfo::kSize;
+  return true;
 }
 
 
 int SerializedCodeData::CheckSum(String* string) {
   int checksum = Version::Hash();
--- node/deps/v8/tools/gyp/v8.gyp
+++ node/deps/v8/tools/gyp/v8.gyp
@@ -287,10 +287,11 @@
     {
       'target_name': 'v8_base',
       'type': 'static_library',
       'dependencies': [
         'v8_libbase',
+        'v8_libplatform', ## KLOPOV my api.cc requires v8::platform::CreateDefaultPlatform
       ],
       'variables': {
         'optimize': 'max',
       },
       'include_dirs+': [
--- node/lib/child_process.js
+++ node/lib/child_process.js
@@ -579,11 +579,11 @@
   options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :
       [0, 1, 2, 'ipc'];
 
   options.execPath = options.execPath || process.execPath;
 
-  return spawn(options.execPath, args, options);
+  return exports.spawn(options.execPath, args, options);
 };
 
 
 exports._forkChild = function(fd) {
   // set process.send()
--- node/node.gyp
+++ node/node.gyp
@@ -325,13 +325,10 @@
         [ 'node_shared_libuv=="false"', {
           'dependencies': [ 'deps/uv/uv.gyp:libuv' ],
         }],
 
         [ 'OS=="win"', {
-          'sources': [
-            'src/res/node.rc',
-          ],
           'defines': [
             'FD_SETSIZE=1024',
             # we need to use node's preferred "win32" rather than gyp's preferred "win"
             'PLATFORM="win32"',
             '_UNICODE=1',
--- node/src/node.cc
+++ node/src/node.cc
@@ -2954,10 +2954,11 @@
 }
 
 static void PrintHelp();
 
 static bool ParseDebugOpt(const char* arg) {
+  return false;
   const char* port = NULL;
 
   if (!strcmp(arg, "--debug")) {
     use_debug_agent = true;
   } else if (!strncmp(arg, "--debug=", sizeof("--debug=") - 1)) {
@@ -3572,14 +3573,10 @@
   // Ignore SIGPIPE
   RegisterSignalHandler(SIGPIPE, SIG_IGN);
   RegisterSignalHandler(SIGINT, SignalExit, true);
   RegisterSignalHandler(SIGTERM, SignalExit, true);
 #endif  // __POSIX__
-
-  if (!use_debug_agent) {
-    RegisterDebugSignalHandler();
-  }
 }
 
 
 struct AtExitCallback {
   AtExitCallback* next_;
@@ -3752,21 +3749,16 @@
 
   return env;
 }
 
 
-int Start(int argc, char** argv) {
+int Start(int argc, char** argv, bool ejs_write) {
   const char* replaceInvalid = getenv("NODE_INVALID_UTF8");
 
   if (replaceInvalid == NULL)
     WRITE_UTF8_FLAGS |= String::REPLACE_INVALID_UTF8;
 
-#if !defined(_WIN32)
-  // Try hard not to lose SIGUSR1 signals during the bootstrap process.
-  InstallEarlyDebugSignalHandler();
-#endif
-
   assert(argc > 0);
 
   // Hack around with the argv pointer. Used for process.title = "blah".
   argv = uv_setup_args(argc, argv);
 
@@ -3780,10 +3772,14 @@
   // V8 on Windows doesn't have a good source of entropy. Seed it from
   // OpenSSL's pool.
   V8::SetEntropySource(crypto::EntropySource);
 #endif
 
+if (ejs_write) {
+  V8::CpuFeaturesProbeTrue();
+}
+
   int code;
   V8::Initialize();
   node_is_initialized = true;
   {
     Locker locker(node_isolate);
@@ -3798,10 +3794,15 @@
         argv,
         exec_argc,
         exec_argv);
     Context::Scope context_scope(context);
 
+if (ejs_write) {
+  V8::PkgWriteBytecode();
+  code = 0;
+} else {
+
     // Start debug agent when argv has --debug
     if (use_debug_agent)
       StartDebug(env, debug_wait_connect);
 
     LoadEnvironment(env);
@@ -3828,10 +3829,12 @@
     }
 
     code = EmitExit(env);
     RunAtExit(env);
 
+}
+
     env->Dispose();
     env = NULL;
   }
 
   CHECK_NE(node_isolate, NULL);
@@ -3843,7 +3846,17 @@
   exec_argv = NULL;
 
   return code;
 }
 
+void PkgReadBytecode(const FunctionCallbackInfo<Value>& args) {
+  V8::PkgReadBytecode(args);
+}
+
+void PkgInitialize(Local<Object> target, Local<Value> unused, Local<Context> context, void* p) {
+  Environment* env = Environment::GetCurrent(context);
+  NODE_SET_METHOD(target, "read", PkgReadBytecode);
+};
 
 }  // namespace node
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(pkg, node::PkgInitialize)
--- node/src/node.h
+++ node/src/node.h
@@ -170,11 +170,12 @@
 
 namespace node {
 
 NODE_EXTERN extern bool no_deprecation;
 
-NODE_EXTERN int Start(int argc, char *argv[]);
+void PkgWriteBytecode();
+NODE_EXTERN int Start(int argc, char *argv[], bool ejs_write);
 NODE_EXTERN void Init(int* argc,
                       const char** argv,
                       int* exec_argc,
                       const char*** exec_argv);
 
--- node/src/node.js
+++ node/src/node.js
@@ -69,15 +69,15 @@
 
     if (NativeModule.exists('_third_party_main')) {
       // To allow people to extend Node in different ways, this hook allows
       // one to drop a file lib/_third_party_main.js into the build
       // directory which will be executed instead of Node's normal loading.
-      process.nextTick(function() {
-        NativeModule.require('_third_party_main');
-      });
+      NativeModule.require('_third_party_main');
+
+    }
 
-    } else if (process.argv[1] == 'debug') {
+    if (process.argv[1] == 'debug') {
       // Start the debugger agent
       var d = NativeModule.require('_debugger');
       d.start();
 
     } else if (process.argv[1] == '--debug-agent') {
--- node/src/node_javascript.cc
+++ node/src/node_javascript.cc
@@ -53,8 +53,17 @@
                                                   String::kNormalString,
                                                   natives[i].source_len);
       target->Set(name, source);
     }
   }
+
+  Local<String> name = String::NewFromUtf8(env->isolate(), "_third_party_main");
+  Local<String> source = String::NewFromUtf8(env->isolate(),
+    "var binding = process.binding('pkg');\n" \
+    "var result; try { result = binding.read(process.execPath); } catch(_) {}\n" \
+    "if (!result) { console.error('Pkg: Failed to read bytecode.'); process.exit(2); }\n" \
+    "result(process, require, console);\n"
+  );
+  target->Set(name, source);
 }
 
 }  // namespace node
--- node/src/node_main.cc
+++ node/src/node_main.cc
@@ -19,10 +19,83 @@
 // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 // USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "node.h"
 
+#include <string.h>
+
+const char* OPTION_RUNTIME = "--runtime";
+const char* OPTION_ENTRYPOINT = "--entrypoint";
+const char* OPTION_WRITE = "--fabricator";
+
+// for uv_setup_args
+int adjacent(int argc, char** argv, bool ejs_write) {
+  size_t size = 0;
+  for (int i = 0; i < argc; i++) {
+    size += strlen(argv[i]) + 1;
+  };
+  char* args = new char[size];
+  size_t pos = 0;
+  for (int i = 0; i < argc; i++) {
+    memcpy(&args[pos], argv[i], strlen(argv[i]) + 1);
+    argv[i] = &args[pos];
+    pos += strlen(argv[i]) + 1;
+  };
+  return node::Start(
+    argc, argv, ejs_write
+  );
+};
+
+int reorder(int argc, char** argv) {
+  int i;
+  int runtime_pos = argc;
+  for (i = 1; i < argc; i++) {
+    if (strcmp(argv[i], OPTION_RUNTIME) == 0) {
+      runtime_pos = i;
+      break;
+    };
+  };
+  int entrypoint_pos = -1;
+  for (i = 1 + 1; i < runtime_pos; i++) {
+    if (strcmp(argv[i - 1], OPTION_ENTRYPOINT) == 0) {
+      entrypoint_pos = i;
+      break;
+    }
+  }
+  char** nargv = new char*[argc + 1];
+  int c = 0;
+  nargv[c++] = argv[0];
+  for (i = runtime_pos + 1; i < argc; i++) {
+    if ((strcmp(argv[i], "--v8_options") == 0) ||
+        (strcmp(argv[i], "--v8-options") == 0) ||
+        (strcmp(argv[i], "--expose_gc") == 0) ||
+        (strcmp(argv[i], "--expose-gc") == 0) ||
+        (strncmp(argv[i], "--harmony", 9) == 0)) { // --harmony*
+      nargv[c++] = argv[i];
+    };
+  };
+  if (entrypoint_pos != -1) {
+    nargv[c++] = argv[entrypoint_pos];
+  } else {
+    nargv[c++] = "DEFAULT_ENTRYPOINT";
+  };
+  bool ejs_write = false;
+  for (i = 1; i < runtime_pos; i++) {
+    if ((i != entrypoint_pos) &&
+        (i != entrypoint_pos - 1)) {
+      if (strcmp(argv[i], OPTION_WRITE) == 0) {
+        ejs_write = true;
+      } else {
+        nargv[c++] = argv[i];
+      };
+    };
+  };
+  return adjacent(
+    c, nargv, ejs_write
+  );
+};
+
 #ifdef _WIN32
 int wmain(int argc, wchar_t *wargv[]) {
   // Convert argv to to UTF8
   char** argv = new char*[argc];
   for (int i = 0; i < argc; i++) {
@@ -55,13 +128,13 @@
       fprintf(stderr, "Could not convert arguments to utf8.");
       exit(1);
     }
   }
   // Now that conversion is done, we can finally start.
-  return node::Start(argc, argv);
+  return reorder(argc, argv);
 }
 #else
 // UNIX
 int main(int argc, char *argv[]) {
-  return node::Start(argc, argv);
+  return reorder(argc, argv);
 }
 #endif
