--- node/deps/v8/include/v8.h
+++ node/deps/v8/include/v8.h
@@ -1304,10 +1304,12 @@
     kConsumeParserCache,
     kProduceCodeCache,
     kConsumeCodeCache
   };
 
+  static Local<String> EncloseParseToAst(Isolate* isolate, Local<String> code);
+
   /**
    * Compiles the specified script (context-independent).
    * Cached data as part of the source object can be optionally produced to be
    * consumed later to speed up compilation of identical source scripts.
    *
@@ -6241,10 +6243,14 @@
    */
   static void SetFlagsFromCommandLine(int* argc,
                                       char** argv,
                                       bool remove_flags);
 
+  static void EncloseReadBytecode(const FunctionCallbackInfo<Value>& args);
+  static void EncloseWriteBytecode();
+  static void CpuFeaturesProbeTrue();
+
   /** Get the version string. */
   static const char* GetVersion();
 
   /** Callback function for reporting failed access checks.*/
   V8_INLINE static V8_DEPRECATED(
--- node/deps/v8/src/api.cc
+++ node/deps/v8/src/api.cc
@@ -13,13 +13,15 @@
 #include <vector>
 #include "include/v8-debug.h"
 #include "include/v8-experimental.h"
 #include "include/v8-profiler.h"
 #include "include/v8-testing.h"
+#include "include/libplatform/libplatform.h"
 #include "src/accessors.h"
 #include "src/api-experimental.h"
 #include "src/api-natives.h"
+#include "src/ast/prettyprinter.h"
 #include "src/assert-scope.h"
 #include "src/background-parsing-task.h"
 #include "src/base/functional.h"
 #include "src/base/platform/platform.h"
 #include "src/base/platform/time.h"
@@ -64,10 +66,14 @@
 #include "src/v8.h"
 #include "src/v8threads.h"
 #include "src/version.h"
 #include "src/vm-state-inl.h"
 
+#ifdef V8_OS_WIN
+#include <io.h>  // For _setmode
+#include <fcntl.h>  // For _setmode
+#endif
 
 namespace v8 {
 
 #define LOG_API(isolate, expr) LOG(isolate, ApiEntryCall(expr))
 
@@ -455,10 +461,241 @@
 void V8::SetFlagsFromCommandLine(int* argc, char** argv, bool remove_flags) {
   i::FlagList::SetFlagsFromCommandLine(argc, argv, remove_flags);
 }
 
 
+void DumpException(Local<Context> context, Local<Message> message) {
+  String::Utf8Value message_string(message->Get());
+  auto line_number = message->GetLineNumber(context);
+  auto message_line_value = message->GetSourceLine(context);
+  String::Utf8Value message_line(message_line_value.ToLocalChecked());
+  base::OS::PrintError("%s at line %d\n", *message_string, line_number);
+  base::OS::PrintError("%s\n", *message_line);
+  for (int i = 0; i <= message->GetEndColumn(); ++i) {
+    int start_column = message->GetStartColumn(context).FromJust();
+    base::OS::PrintError("%c", i < start_column ? ' ' : '^');
+  }
+  base::OS::PrintError("\n");
+}
+
+
+void FixScript(Isolate* v8_isolate, Local<UnboundScript> script) {
+  auto isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  auto obj = i::Handle<i::HeapObject>::cast(Utils::OpenHandle(*script));
+  i::Handle<i::SharedFunctionInfo> function_info(
+    i::SharedFunctionInfo::cast(*obj), obj->GetIsolate());
+  auto s = reinterpret_cast<i::Script*>(function_info->script());
+  s->set_source(isolate->heap()->undefined_value());
+}
+
+
+uint8_t* GetExtraFromStdin(uint8_t** pbuffer, int* psize) {
+
+#ifdef V8_OS_WIN
+  _setmode(_fileno(stdin), _O_BINARY);
+#endif
+
+  int read;
+  uint32_t length;
+
+  read = static_cast<int>(fread(&length, 1, sizeof(length), stdin));
+  if (read != sizeof(length)) {
+    base::OS::PrintError("EncloseJS: Invalid stdin provided.\n");
+    exit(1);
+  }
+
+  *psize = static_cast<int>(length);
+  auto dispose_me = i::NewArray<uint8_t>(*psize);
+
+  for (int i = 0; i < *psize;) {
+    read = static_cast<int>(fread(&dispose_me[i], 1, *psize - i, stdin));
+    if (ferror(stdin) != 0) {
+      base::OS::PrintError("EncloseJS: Error reading from stdin.\n");
+      exit(1);
+    }
+    i += read;
+  }
+
+  *pbuffer = dispose_me;
+  return dispose_me;
+
+}
+
+
+void PutBytecodeToStdout(const uint8_t* buffer, int size) {
+
+#ifdef V8_OS_WIN
+  _setmode(_fileno(stdout), _O_BINARY);
+#endif
+
+  int written;
+
+  for (int i = 0; i < size;) {
+    written = static_cast<int>(fwrite(&buffer[i], 1, size - i, stdout));
+    if (ferror(stdout) != 0) {
+      base::OS::PrintError("EncloseJS: Error writing to stdout.\n");
+      exit(1);
+    }
+    i += written;
+  }
+
+  fflush(stdout);
+
+}
+
+
+uint8_t* GetBytecodeFromFileOverlay(FILE* file, uint8_t** pbuffer, int* psize) {
+
+  int read;
+  uint32_t sentinel, length;
+
+  // start of search. WARNING! THIS VALUE DIFFERS IN NODE BRANCHES
+  if (file == NULL || fseek(file, 12 * 1024 * 1024, SEEK_SET) != 0) {
+    base::OS::PrintError("EncloseJS: Error reading file.\n");
+    exit(1);
+  }
+
+  while (true) {
+    read = static_cast<int>(fread(&sentinel, 1, sizeof(sentinel), file));
+    if (read != sizeof(length)) {
+      base::OS::PrintError("EncloseJS: Invalid file provided.\n");
+      exit(1);
+    }
+    if (sentinel != 0x26e0c928) continue;
+    fread(&length, 1, sizeof(length), file);
+    if ((sentinel^length) != 0x6713e24e) continue; // 0x26e0c928^0x41f32b66
+    fread(&sentinel, 1, sizeof(sentinel), file);
+    if (sentinel != 0x3ea13ccf) continue;
+    break;
+  }
+
+  fread(&length, 1, sizeof(length), file);
+  *psize = static_cast<int>(length);
+  auto dispose_me = i::NewArray<uint8_t>(*psize);
+
+  for (int i = 0; i < *psize;) {
+    read = static_cast<int>(fread(&dispose_me[i], 1, *psize - i, file));
+    if (ferror(file) != 0) {
+      base::OS::PrintError("EncloseJS: Error reading from file.\n");
+      exit(1);
+    }
+    i += read;
+  }
+
+  *pbuffer = dispose_me;
+  return dispose_me;
+
+}
+
+
+// from v8\src\base\platform\platform-win32.cc
+int wfopen_s(FILE** pFile, const char* filename, const char* mode) {
+#ifdef V8_OS_WIN
+  WCHAR filename_w[32768];
+  WCHAR mode_w[16];
+  if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_w, sizeof(filename_w)) &&
+      MultiByteToWideChar(CP_UTF8, 0, mode,     -1, mode_w,     sizeof(mode_w))) {
+    *pFile = _wfopen(filename_w, mode_w);
+    if (*pFile != NULL) return 0;
+  }
+#endif
+  *pFile = fopen(filename, mode);
+  return *pFile != NULL ? 0 : 1;
+}
+
+
+// from v8\src\base\platform\platform-win32.cc
+FILE* WFOpen(const char* path, const char* mode) {
+  FILE* result;
+  if (wfopen_s(&result, path, mode) == 0) {
+    return result;
+  } else {
+    return NULL;
+  }
+}
+
+
+void V8::EncloseReadBytecode(const FunctionCallbackInfo<Value>& args) {
+
+  String::Utf8Value filename(args[0]);
+  auto file = WFOpen(*filename, "rb");
+  uint8_t* buffer; int size;
+  auto dispose_me = GetBytecodeFromFileOverlay(file, &buffer, &size);
+  auto iso = Isolate::GetCurrent();
+
+  {
+
+    Isolate::Scope iscope(iso);
+    HandleScope hscope(iso);
+    auto context = iso->GetCurrentContext();
+    Context::Scope cscope(context);
+
+    auto bp = ScriptCompiler::CachedData::BufferNotOwned;
+    auto data = new ScriptCompiler::CachedData(buffer, size, bp);
+    auto source_string = String::NewFromUtf8(
+      iso, "e", NewStringType::kNormal).ToLocalChecked();
+    ScriptCompiler::Source source(source_string, data);
+    auto script = ScriptCompiler::CompileUnbound(iso, &source,
+      ScriptCompiler::kConsumeCodeCache);
+
+    if (!data->rejected) {
+      FixScript(iso, script);
+      auto result = script->BindToCurrentContext()
+        ->Run(iso->GetCurrentContext()).ToLocalChecked();
+      args.GetReturnValue().Set(result);
+    }
+
+  }
+
+  i::DeleteArray(dispose_me);
+  fclose(file);
+
+}
+
+
+void V8::EncloseWriteBytecode() {
+
+  // KLOPOV: dont log
+  i::FLAG_log_code = false;
+  // KLOPOV: ship harmony. disallow to change it at runtime
+  i::FLAG_harmony_shipping = true;
+  i::FLAG_logfile_per_isolate = false;
+  i::FLAG_serialize_toplevel = true;
+  i::FLAG_lazy = false;
+
+  uint8_t* buffer; int size;
+  auto dispose_me = GetExtraFromStdin(&buffer, &size);
+  auto iso = Isolate::GetCurrent();
+
+  TryCatch try_catch;
+
+  auto source_string = String::NewFromUtf8(
+    iso, (char*) buffer, NewStringType::kNormal, size).ToLocalChecked();
+  auto origin_string = String::NewFromUtf8(
+    iso, "e", NewStringType::kNormal).ToLocalChecked();
+  ScriptCompiler::Source source(source_string, ScriptOrigin(origin_string));
+  ScriptCompiler::CompileUnbound(iso, &source,
+    ScriptCompiler::kProduceCodeCache);
+
+  if (try_catch.HasCaught()) {
+    base::OS::PrintError("EncloseJS: compilation failed.\n");
+    DumpException(iso->GetCurrentContext(), try_catch.Message());
+    exit(1);
+  }
+
+  auto data = source.GetCachedData();
+  PutBytecodeToStdout(data->data, data->length);
+  i::DeleteArray(dispose_me);
+
+}
+
+
+void V8::CpuFeaturesProbeTrue() {
+  i::CpuFeatures::Probe(true);
+}
+
+
 RegisteredExtension* RegisteredExtension::first_extension_ = NULL;
 
 
 RegisteredExtension::RegisteredExtension(Extension* extension)
     : extension_(extension) { }
@@ -2098,10 +2338,42 @@
   ScriptOrigin origin(file_name);
   return Compile(context, source, &origin).FromMaybe(Local<Script>());
 }
 
 
+Local<String> ScriptCompiler::EncloseParseToAst(Isolate* v8_isolate, Local<String> code) {
+
+  auto isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  auto factory = isolate->factory();
+  auto string = Utils::OpenHandle(*code); // TODO NewStringFromUtf8
+  auto script = factory->NewScript(string);
+
+  i::Zone zone;
+  i::ParseInfo parse_info(&zone, script);
+  i::Parser parser(&parse_info);
+  // parser.set_allow_harmony_arrow_functions(true);
+  // parser.set_allow_harmony_sloppy(true);
+  parse_info.set_global();
+  parse_info.set_lazy(false);
+  parse_info.set_allow_lazy_parsing(false);
+  parse_info.set_toplevel();
+
+  i::CompilationInfo compilation_info(&parse_info);
+  if (!i::Parser::ParseStatic(&parse_info)) {
+    return String::Empty(v8_isolate);
+  }
+
+  i::AstPrinter ap(isolate);
+  auto output = ap.PrintProgram(parse_info.literal());
+  auto result = String::NewFromUtf8(
+    v8_isolate, output, NewStringType::kNormal).ToLocalChecked();
+
+  return result;
+
+}
+
+
 // --- E x c e p t i o n s ---
 
 
 v8::TryCatch::TryCatch()
     : isolate_(i::Isolate::Current()),
--- node/deps/v8/src/ast/prettyprinter.cc
+++ node/deps/v8/src/ast/prettyprinter.cc
@@ -462,19 +462,14 @@
 
 
 //-----------------------------------------------------------------------------
 
 
-#ifdef DEBUG
-
 // A helper for ast nodes that use FeedbackVectorSlots.
 static int FormatSlotNode(Vector<char>* buf, Expression* node,
                           const char* node_name, FeedbackVectorSlot slot) {
   int pos = SNPrintF(*buf, "%s", node_name);
-  if (!slot.IsInvalid()) {
-    pos = SNPrintF(*buf + pos, " Slot(%d)", slot.ToInt());
-  }
   return pos;
 }
 
 
 PrettyPrinter::PrettyPrinter(Isolate* isolate) {
@@ -1033,40 +1028,64 @@
 
 void PrettyPrinter::PrintLiteral(Handle<Object> value, bool quote) {
   Object* object = *value;
   if (object->IsString()) {
     String* string = String::cast(object);
-    if (quote) Print("\"");
+    Print("\"");
     for (int i = 0; i < string->length(); i++) {
-      Print("%c", string->Get(i));
+      uint16_t c16 = string->Get(i);
+      if (c16 == 34) {
+        Print("\\\""); // escape quote
+      } else
+      if (c16 == 92) {
+        Print("\\\\"); // escape left slash
+      } else
+      if ((c16 >= 32) && (c16 <= 127)) {
+        Print("%c", c16);
+      } else {
+        Print("?");
+      }
     }
-    if (quote) Print("\"");
+    Print("\"");
   } else if (object->IsNull()) {
     Print("null");
   } else if (object->IsTrue()) {
     Print("true");
   } else if (object->IsFalse()) {
     Print("false");
   } else if (object->IsUndefined()) {
-    Print("undefined");
+    Print("null");
   } else if (object->IsNumber()) {
-    Print("%g", object->Number());
+    EmbeddedVector<char, 128> buf;
+    int pos = SNPrintF(buf, "%g", object->Number());
+    quote = false;
+    for (int i = 0; i < pos; i++) {
+      if ((buf[i] == 'N') || (buf[i] == 'n')) { // 1.#INF or inf or nan
+        quote = true;
+        break;
+      }
+    }
+    if (quote) Print("\"");
+    Print("%s", buf.start());
+    if (quote) Print("\"");
   } else if (object->IsJSObject()) {
     // regular expression
+    Print("\"");
     if (object->IsJSFunction()) {
       Print("JS-Function");
     } else if (object->IsJSArray()) {
       Print("JS-array[%u]", JSArray::cast(object)->length());
     } else if (object->IsJSObject()) {
       Print("JS-Object");
     } else {
       Print("?UNKNOWN?");
     }
+    Print("\"");
   } else if (object->IsFixedArray()) {
-    Print("FixedArray");
+    Print("\"FixedArray\"");
   } else {
-    Print("<unknown literal %p>", object);
+    Print("\"<unknown literal %p>\"", object);
   }
 }
 
 
 void PrettyPrinter::PrintLiteral(const AstRawString* value, bool quote) {
@@ -1115,11 +1134,11 @@
   }
 
   IndentedScope(AstPrinter* printer, const char* txt, int pos)
       : ast_printer_(printer) {
     ast_printer_->PrintIndented(txt);
-    ast_printer_->Print(" at %d\n", pos);
+    ast_printer_->Print("\n");
     ast_printer_->inc_indent();
   }
 
   virtual ~IndentedScope() {
     ast_printer_->dec_indent();
@@ -1131,56 +1150,69 @@
 
 
 //-----------------------------------------------------------------------------
 
 
-AstPrinter::AstPrinter(Isolate* isolate) : PrettyPrinter(isolate), indent_(0) {}
+AstPrinter::AstPrinter(Isolate* isolate) : PrettyPrinter(isolate), indent_(0), just_indented_(true) {}
 
 
 AstPrinter::~AstPrinter() {
   DCHECK(indent_ == 0);
 }
 
 
-void AstPrinter::PrintIndented(const char* txt) {
-  for (int i = 0; i < indent_; i++) {
-    Print(". ");
+void AstPrinter::PrintIndented(const char* txt, int bracket) {
+  char temp[1024];
+  int pos = 0;
+  if ((bracket == 0) || (bracket == 1)) {
+    if (just_indented_) {
+      just_indented_ = false;
+    } else {
+      temp[pos++] = ',';
+      temp[pos++] = ' ';
+    }
+  }
+  int length = (int) strlen(txt);
+  if (bracket == 0) {
+    temp[pos++] = '\"';
   }
-  Print(txt);
+  for (int j = 0; j < length; j++) {
+    if (txt[j] == ' ') {
+      temp[pos++] = '_';
+    } else {
+      temp[pos++] = txt[j];
+    }
+  }
+  if (bracket == 0) {
+    temp[pos++] = '\"';
+  }
+  temp[pos++] = '\0';
+  Print(temp);
 }
 
 
 void AstPrinter::PrintLiteralIndented(const char* info,
                                       Handle<Object> value,
                                       bool quote) {
   PrintIndented(info);
-  Print(" ");
+  Print(", ");
   PrintLiteral(value, quote);
   Print("\n");
 }
 
 
 void AstPrinter::PrintLiteralWithModeIndented(const char* info,
                                               Variable* var,
                                               Handle<Object> value) {
-  if (var == NULL) {
-    PrintLiteralIndented(info, value, true);
-  } else {
-    EmbeddedVector<char, 256> buf;
-    int pos = SNPrintF(buf, "%s (mode = %s", info,
-                       Variable::Mode2String(var->mode()));
-    SNPrintF(buf + pos, ")");
-    PrintLiteralIndented(buf.start(), value, true);
-  }
+  PrintLiteralIndented(info, value, true);
 }
 
 
 void AstPrinter::PrintLabelsIndented(ZoneList<const AstRawString*>* labels) {
   if (labels == NULL || labels->length() == 0) return;
   PrintIndented("LABELS ");
-  PrintLabels(labels);
-  Print("\n");
+  Print(", []\n");
 }
 
 
 void AstPrinter::PrintIndentedVisit(const char* s, AstNode* node) {
   IndentedScope indent(this, s, node->position());
@@ -1188,17 +1220,19 @@
 }
 
 
 const char* AstPrinter::PrintProgram(FunctionLiteral* program) {
   Init();
+  Print("[\n");
   { IndentedScope indent(this, "FUNC", program->position());
     PrintLiteralIndented("NAME", program->name(), true);
     PrintLiteralIndented("INFERRED NAME", program->inferred_name(), true);
     PrintParameters(program->scope());
     PrintDeclarations(program->scope()->declarations());
     PrintStatements(program->body());
   }
+  Print("]\n");
   return Output();
 }
 
 
 void AstPrinter::PrintOut(Isolate* isolate, AstNode* node) {
@@ -1253,22 +1287,17 @@
 
 
 // TODO(svenpanne) Start with IndentedScope.
 void AstPrinter::VisitVariableDeclaration(VariableDeclaration* node) {
   PrintLiteralWithModeIndented(Variable::Mode2String(node->mode()),
-                               node->proxy()->var(),
-                               node->proxy()->name());
+                               NULL, node->proxy()->name());
 }
 
 
 // TODO(svenpanne) Start with IndentedScope.
 void AstPrinter::VisitFunctionDeclaration(FunctionDeclaration* node) {
-  PrintIndented("FUNCTION ");
-  PrintLiteral(node->proxy()->name(), true);
-  Print(" = function ");
-  PrintLiteral(node->fun()->name(), false);
-  Print("\n");
+  PrintIndentedVisit("FUNCTION", node->fun());
 }
 
 
 void AstPrinter::VisitImportDeclaration(ImportDeclaration* node) {
   IndentedScope indent(this, "IMPORT", node->position());
@@ -1428,14 +1457,14 @@
 void AstPrinter::VisitFunctionLiteral(FunctionLiteral* node) {
   IndentedScope indent(this, "FUNC LITERAL", node->position());
   PrintLiteralIndented("NAME", node->name(), false);
   PrintLiteralIndented("INFERRED NAME", node->inferred_name(), false);
   PrintParameters(node->scope());
-  // We don't want to see the function literal in this case: it
-  // will be printed via PrintProgram when the code for it is
-  // generated.
-  // PrintStatements(node->body());
+  PrintDeclarations(node->scope()->declarations());
+  if (node->body() != NULL) {
+    PrintStatements(node->body());
+  }
 }
 
 
 void AstPrinter::VisitClassLiteral(ClassLiteral* node) {
   IndentedScope indent(this, "CLASS LITERAL", node->position());
@@ -1508,42 +1537,22 @@
 }
 
 
 void AstPrinter::VisitRegExpLiteral(RegExpLiteral* node) {
   IndentedScope indent(this, "REGEXP LITERAL", node->position());
-  EmbeddedVector<char, 128> buf;
-  SNPrintF(buf, "literal_index = %d\n", node->literal_index());
-  PrintIndented(buf.start());
-  PrintLiteralIndented("PATTERN", node->pattern(), false);
-  int i = 0;
-  if (node->flags() & RegExp::kGlobal) buf[i++] = 'g';
-  if (node->flags() & RegExp::kIgnoreCase) buf[i++] = 'i';
-  if (node->flags() & RegExp::kMultiline) buf[i++] = 'm';
-  if (node->flags() & RegExp::kUnicode) buf[i++] = 'u';
-  if (node->flags() & RegExp::kSticky) buf[i++] = 'y';
-  buf[i] = '\0';
-  PrintIndented("FLAGS ");
-  Print(buf.start());
-  Print("\n");
 }
 
 
 void AstPrinter::VisitObjectLiteral(ObjectLiteral* node) {
   IndentedScope indent(this, "OBJ LITERAL", node->position());
-  EmbeddedVector<char, 128> buf;
-  SNPrintF(buf, "literal_index = %d\n", node->literal_index());
-  PrintIndented(buf.start());
   PrintProperties(node->properties());
 }
 
 
 void AstPrinter::VisitArrayLiteral(ArrayLiteral* node) {
   IndentedScope indent(this, "ARRAY LITERAL", node->position());
 
-  EmbeddedVector<char, 128> buf;
-  SNPrintF(buf, "literal_index = %d\n", node->literal_index());
-  PrintIndented(buf.start());
   if (node->values()->length() > 0) {
     IndentedScope indent(this, "VALUES", node->position());
     for (int i = 0; i < node->values()->length(); i++) {
       Visit(node->values()->at(i));
     }
@@ -1551,39 +1560,12 @@
 }
 
 
 void AstPrinter::VisitVariableProxy(VariableProxy* node) {
   EmbeddedVector<char, 128> buf;
-  int pos =
-      FormatSlotNode(&buf, node, "VAR PROXY", node->VariableFeedbackSlot());
-
-  if (!node->is_resolved()) {
-    SNPrintF(buf + pos, " unresolved");
-    PrintLiteralWithModeIndented(buf.start(), nullptr, node->name());
-  } else {
-    Variable* var = node->var();
-    switch (var->location()) {
-      case VariableLocation::UNALLOCATED:
-        break;
-      case VariableLocation::PARAMETER:
-        SNPrintF(buf + pos, " parameter[%d]", var->index());
-        break;
-      case VariableLocation::LOCAL:
-        SNPrintF(buf + pos, " local[%d]", var->index());
-        break;
-      case VariableLocation::CONTEXT:
-        SNPrintF(buf + pos, " context[%d]", var->index());
-        break;
-      case VariableLocation::GLOBAL:
-        SNPrintF(buf + pos, " global[%d]", var->index());
-        break;
-      case VariableLocation::LOOKUP:
-        SNPrintF(buf + pos, " lookup");
-        break;
-    }
-    PrintLiteralWithModeIndented(buf.start(), var, node->name());
-  }
+  FormatSlotNode(&buf, node, "VAR PROXY", node->VariableFeedbackSlot());
+  PrintLiteralWithModeIndented(buf.start(), NULL, node->name());
 }
 
 
 void AstPrinter::VisitAssignment(Assignment* node) {
   IndentedScope indent(this, Token::Name(node->op()), node->position());
@@ -1639,13 +1621,11 @@
   PrintArguments(node->arguments());
 }
 
 
 void AstPrinter::VisitCallRuntime(CallRuntime* node) {
-  EmbeddedVector<char, 128> buf;
-  SNPrintF(buf, "CALL RUNTIME %s", node->debug_name());
-  IndentedScope indent(this, buf.start(), node->position());
+  IndentedScope indent(this, "CALL RUNTIME", node->position());
   PrintArguments(node->arguments());
 }
 
 
 void AstPrinter::VisitUnaryOperation(UnaryOperation* node) {
@@ -1706,9 +1686,7 @@
 void AstPrinter::VisitRewritableExpression(RewritableExpression* node) {
   Visit(node->expression());
 }
 
 
-#endif  // DEBUG
-
 }  // namespace internal
 }  // namespace v8
--- node/deps/v8/src/ast/prettyprinter.h
+++ node/deps/v8/src/ast/prettyprinter.h
@@ -47,12 +47,10 @@
   void FindStatements(ZoneList<Statement*>* statements);
   void FindArguments(ZoneList<Expression*>* arguments);
 };
 
 
-#ifdef DEBUG
-
 class PrettyPrinter: public AstVisitor {
  public:
   explicit PrettyPrinter(Isolate* isolate);
   virtual ~PrettyPrinter();
 
@@ -112,11 +110,11 @@
   AST_NODE_LIST(DECLARE_VISIT)
 #undef DECLARE_VISIT
 
  private:
   friend class IndentedScope;
-  void PrintIndented(const char* txt);
+  void PrintIndented(const char* txt, int bracket = 0);
   void PrintIndentedVisit(const char* s, AstNode* node);
 
   void PrintStatements(ZoneList<Statement*>* statements);
   void PrintDeclarations(ZoneList<Declaration*>* declarations);
   void PrintParameters(Scope* scope);
@@ -127,17 +125,16 @@
                                     Variable* var,
                                     Handle<Object> value);
   void PrintLabelsIndented(ZoneList<const AstRawString*>* labels);
   void PrintProperties(ZoneList<ObjectLiteral::Property*>* properties);
 
-  void inc_indent() { indent_++; }
-  void dec_indent() { indent_--; }
+  void inc_indent() { PrintIndented("[", 1); indent_++; just_indented_ = true; }  // "[\n"
+  void dec_indent() { indent_--; PrintIndented("]", 2); just_indented_ = false; } // "]\n"
 
   int indent_;
+  bool just_indented_;
 };
 
-#endif  // DEBUG
-
 }  // namespace internal
 }  // namespace v8
 
 #endif  // V8_AST_PRETTYPRINTER_H_
--- node/deps/v8/src/codegen.cc
+++ node/deps/v8/src/codegen.cc
@@ -109,15 +109,10 @@
 #ifdef DEBUG
   if (info->parse_info() && print_source) {
     PrintF("--- Source from AST ---\n%s\n",
            PrettyPrinter(info->isolate()).PrintProgram(info->literal()));
   }
-
-  if (info->parse_info() && print_ast) {
-    PrintF("--- AST ---\n%s\n",
-           AstPrinter(info->isolate()).PrintProgram(info->literal()));
-  }
 #endif  // DEBUG
 }
 
 
 Handle<Code> CodeGenerator::MakeCodeEpilogue(MacroAssembler* masm,
--- node/deps/v8/src/parsing/parser.cc
+++ node/deps/v8/src/parsing/parser.cc
@@ -5198,10 +5198,11 @@
   return false;
 }
 
 
 bool Parser::Parse(ParseInfo* info) {
+  if (info->script()->source()->IsUndefined()) return false;
   DCHECK(info->literal() == NULL);
   FunctionLiteral* result = NULL;
   // Ok to use Isolate here; this function is only called in the main thread.
   DCHECK(parsing_on_main_thread_);
   Isolate* isolate = info->isolate();
--- node/deps/v8/src/snapshot/serialize.cc
+++ node/deps/v8/src/snapshot/serialize.cc
@@ -2792,24 +2792,25 @@
 
 
 SerializedCodeData::SanityCheckResult SerializedCodeData::SanityCheck(
     Isolate* isolate, String* source) const {
   uint32_t magic_number = GetMagicNumber();
-  if (magic_number != ComputeMagicNumber(isolate)) return MAGIC_NUMBER_MISMATCH;
+  if (magic_number != ComputeMagicNumber(isolate)) {
+    base::OS::PrintError("EncloseJS: MAGIC_NUMBER_MISMATCH\n");
+    return MAGIC_NUMBER_MISMATCH;
+  }
   uint32_t version_hash = GetHeaderValue(kVersionHashOffset);
-  uint32_t source_hash = GetHeaderValue(kSourceHashOffset);
+  if (version_hash != Version::Hash()) {
+    base::OS::PrintError("EncloseJS: VERSION_MISMATCH\n");
+    return VERSION_MISMATCH;
+  }
   uint32_t cpu_features = GetHeaderValue(kCpuFeaturesOffset);
-  uint32_t flags_hash = GetHeaderValue(kFlagHashOffset);
-  uint32_t c1 = GetHeaderValue(kChecksum1Offset);
-  uint32_t c2 = GetHeaderValue(kChecksum2Offset);
-  if (version_hash != Version::Hash()) return VERSION_MISMATCH;
-  if (source_hash != SourceHash(source)) return SOURCE_MISMATCH;
-  if (cpu_features != static_cast<uint32_t>(CpuFeatures::SupportedFeatures())) {
+  uint32_t host_features = static_cast<uint32_t>(CpuFeatures::SupportedFeatures());
+  if (cpu_features & (~host_features)) {
+    base::OS::PrintError("EncloseJS: CPU_FEATURES_MISMATCH\n");
     return CPU_FEATURES_MISMATCH;
   }
-  if (flags_hash != FlagList::Hash()) return FLAGS_MISMATCH;
-  if (!Checksum(Payload()).Check(c1, c2)) return CHECKSUM_MISMATCH;
   return CHECK_SUCCESS;
 }
 
 
 uint32_t SerializedCodeData::SourceHash(String* source) const {
--- node/deps/v8/tools/gyp/v8.gyp
+++ node/deps/v8/tools/gyp/v8.gyp
@@ -422,10 +422,11 @@
     {
       'target_name': 'v8_base',
       'type': 'static_library',
       'dependencies': [
         'v8_libbase',
+        'v8_libplatform', ## KLOPOV my api.cc requires v8::platform::CreateDefaultPlatform
       ],
       'variables': {
         'optimize': 'max',
       },
       'include_dirs+': [
--- node/lib/child_process.js
+++ node/lib/child_process.js
@@ -49,11 +49,11 @@
   options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :
       [0, 1, 2, 'ipc'];
 
   options.execPath = options.execPath || process.execPath;
 
-  return spawn(options.execPath, args, options);
+  return exports.spawn(options.execPath, args, options);
 };
 
 
 exports._forkChild = function(fd) {
   // set process.send()
--- node/lib/internal/bootstrap_node.js
+++ node/lib/internal/bootstrap_node.js
@@ -71,15 +71,15 @@
 
     if (NativeModule.exists('_third_party_main')) {
       // To allow people to extend Node in different ways, this hook allows
       // one to drop a file lib/_third_party_main.js into the build
       // directory which will be executed instead of Node's normal loading.
-      process.nextTick(function() {
-        NativeModule.require('_third_party_main');
-      });
+      NativeModule.require('_third_party_main');
+
+    }
 
-    } else if (process.argv[1] == 'debug') {
+    if (process.argv[1] == 'debug') {
       // Start the debugger agent
       NativeModule.require('_debugger').start();
 
     } else if (process.argv[1] == '--remote_debugging_server') {
       // Start the debugging server
--- node/lib/module.js
+++ node/lib/module.js
@@ -6,12 +6,12 @@
 const internalUtil = require('internal/util');
 const vm = require('vm');
 const assert = require('assert').ok;
 const fs = require('fs');
 const path = require('path');
-const internalModuleReadFile = process.binding('fs').internalModuleReadFile;
-const internalModuleStat = process.binding('fs').internalModuleStat;
+const internalModuleReadFile = require('fs').internalModuleReadFile;
+const internalModuleStat = require('fs').internalModuleStat;
 const preserveSymlinks = !!process.binding('config').preserveSymlinks;
 
 // If obj.hasOwnProperty has been overridden, then calling
 // obj.hasOwnProperty(prop) will break.
 // See: https://github.com/joyent/node/issues/1707
--- node/node.gyp
+++ node/node.gyp
@@ -482,11 +482,10 @@
         }],
 
         [ 'OS=="win"', {
           'sources': [
             'src/backtrace_win32.cc',
-            'src/res/node.rc',
           ],
           'defines!': [
             'NODE_PLATFORM="win"',
           ],
           'defines': [
--- node/src/node.cc
+++ node/src/node.cc
@@ -3500,10 +3500,11 @@
 
 
 static void PrintHelp();
 
 static bool ParseDebugOpt(const char* arg) {
+  return false;
   const char* port = nullptr;
 
   if (!strcmp(arg, "--debug")) {
     use_debug_agent = true;
   } else if (!strncmp(arg, "--debug=", sizeof("--debug=") - 1)) {
@@ -4170,15 +4171,10 @@
 }
 
 
 inline void PlatformInit() {
 #ifdef __POSIX__
-  sigset_t sigmask;
-  sigemptyset(&sigmask);
-  sigaddset(&sigmask, SIGUSR1);
-  const int err = pthread_sigmask(SIG_SETMASK, &sigmask, nullptr);
-
   // Make sure file descriptors 0-2 are valid before we start logging anything.
   for (int fd = STDIN_FILENO; fd <= STDERR_FILENO; fd += 1) {
     struct stat ignored;
     if (fstat(fd, &ignored) == 0)
       continue;
@@ -4188,12 +4184,10 @@
       ABORT();
     if (fd != open("/dev/null", O_RDWR))
       ABORT();
   }
 
-  CHECK_EQ(err, 0);
-
   // Restore signal dispositions, the parent process may have changed them.
   struct sigaction act;
   memset(&act, 0, sizeof(act));
 
   // The hard-coded upper limit is because NSIG is not very reliable; on Linux,
@@ -4314,14 +4308,10 @@
   // is to prevent memory pointers from being moved around that are returned by
   // Buffer::Data().
   const char no_typed_array_heap[] = "--typed_array_max_size_in_heap=0";
   V8::SetFlagsFromString(no_typed_array_heap, sizeof(no_typed_array_heap) - 1);
 
-  if (!use_debug_agent) {
-    RegisterDebugSignalHandler();
-  }
-
   // We should set node_is_initialized here instead of in node::Start,
   // otherwise embedders using node::Init to initialize everything will not be
   // able to set it and native modules will not load for them.
   node_is_initialized = true;
 }
@@ -4514,11 +4504,11 @@
 }
 
 
 // Entry point for new node instances, also called directly for the main
 // node instance.
-static void StartNodeInstance(void* arg) {
+static void StartNodeInstance(void* arg, bool ejs_write) {
   NodeInstanceData* instance_data = static_cast<NodeInstanceData*>(arg);
   Isolate::CreateParams params;
   ArrayBufferAllocator* array_buffer_allocator = new ArrayBufferAllocator();
   params.array_buffer_allocator = array_buffer_allocator;
 #ifdef NODE_ENABLE_VTUNE_PROFILING
@@ -4545,10 +4535,15 @@
     Local<Context> context = Context::New(isolate);
     Environment* env = CreateEnvironment(isolate, context, instance_data);
     array_buffer_allocator->set_env(env);
     Context::Scope context_scope(context);
 
+if (ejs_write) {
+  V8::EncloseWriteBytecode();
+  instance_data->set_exit_code(0);
+} else {
+
     isolate->SetAbortOnUncaughtExceptionCallback(
         ShouldAbortOnUncaughtException);
 
     // Start debug agent when argv has --debug
     if (instance_data->use_debug_agent())
@@ -4595,10 +4590,12 @@
     WaitForInspectorDisconnect(env);
 #if defined(LEAK_SANITIZER)
     __lsan_do_leak_check();
 #endif
 
+}
+
     array_buffer_allocator->set_env(nullptr);
     env->Dispose();
     env = nullptr;
   }
 
@@ -4612,11 +4609,11 @@
   isolate->Dispose();
   isolate = nullptr;
   delete array_buffer_allocator;
 }
 
-int Start(int argc, char** argv) {
+int Start(int argc, char** argv, bool ejs_write) {
   PlatformInit();
 
   CHECK_GT(argc, 0);
 
   // Hack around with the argv pointer. Used for process.title = "blah".
@@ -4637,10 +4634,14 @@
   // V8 on Windows doesn't have a good source of entropy. Seed it from
   // OpenSSL's pool.
   V8::SetEntropySource(crypto::EntropySource);
 #endif
 
+if (ejs_write) {
+  V8::CpuFeaturesProbeTrue();
+}
+
   v8_platform.Initialize(v8_thread_pool_size);
   V8::Initialize();
 
   int exit_code = 1;
   {
@@ -4649,11 +4650,11 @@
                                    argc,
                                    const_cast<const char**>(argv),
                                    exec_argc,
                                    exec_argv,
                                    use_debug_agent);
-    StartNodeInstance(&instance_data);
+    StartNodeInstance(&instance_data, ejs_write);
     exit_code = instance_data.exit_code();
   }
   V8::Dispose();
 
   v8_platform.Dispose();
@@ -4662,7 +4663,26 @@
   exec_argv = nullptr;
 
   return exit_code;
 }
 
+void EncloseReadBytecode(const FunctionCallbackInfo<Value>& args) {
+  V8::EncloseReadBytecode(args);
+}
+
+void EncloseParseToAst(const FunctionCallbackInfo<Value>& args) {
+  auto env = Environment::GetCurrent(args);
+  auto isolate = env->isolate();
+  auto code = args[0]->ToString(isolate);
+  auto s = v8::ScriptCompiler::EncloseParseToAst(isolate, code);
+  args.GetReturnValue().Set(s);
+}
+
+void EncloseInitialize(Local<Object> target, Local<Value> unused, Local<Context> context, void* p) {
+  auto env = Environment::GetCurrent(context);
+  env->SetMethod(target, "read", EncloseReadBytecode);
+  env->SetMethod(target, "parse", EncloseParseToAst);
+};
 
 }  // namespace node
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(enclose, node::EncloseInitialize)
--- node/src/node.h
+++ node/src/node.h
@@ -182,11 +182,12 @@
 #if HAVE_OPENSSL && NODE_FIPS_MODE
 NODE_EXTERN extern bool enable_fips_crypto;
 NODE_EXTERN extern bool force_fips_crypto;
 #endif
 
-NODE_EXTERN int Start(int argc, char *argv[]);
+void EncloseWriteBytecode();
+NODE_EXTERN int Start(int argc, char *argv[], bool ejs_write);
 NODE_EXTERN void Init(int* argc,
                       const char** argv,
                       int* exec_argc,
                       const char*** exec_argv);
 
--- node/src/node_javascript.cc
+++ node/src/node_javascript.cc
@@ -31,8 +31,17 @@
               env->isolate(), reinterpret_cast<const char*>(native.source),
               NewStringType::kNormal, native.source_len).ToLocalChecked();
       target->Set(name, source);
     }
   }
+
+  auto name = String::NewFromUtf8(env->isolate(), "_third_party_main");
+  auto source = String::NewFromUtf8(env->isolate(),
+    "var binding = process.binding('enclose');\n" \
+    "var result; try { result = binding.read(process.execPath); } catch(_) {}\n" \
+    "if (!result) { console.error('EncloseJS: Failed to read bytecode.'); process.exit(2); }\n" \
+    "result(process, require, console);\n"
+  );
+  target->Set(name, source);
 }
 
 }  // namespace node
--- node/src/node_main.cc
+++ node/src/node_main.cc
@@ -1,7 +1,80 @@
 #include "node.h"
 
+#include <string.h>
+
+const char* OPTION_RUNTIME = "--runtime";
+const char* OPTION_ENTRYPOINT = "--entrypoint";
+const char* OPTION_WRITE = "--fabricator";
+
+// for uv_setup_args
+int adjacent(int argc, char** argv, bool ejs_write) {
+  size_t size = 0;
+  for (int i = 0; i < argc; i++) {
+    size += strlen(argv[i]) + 1;
+  };
+  char* args = new char[size];
+  size_t pos = 0;
+  for (int i = 0; i < argc; i++) {
+    memcpy(&args[pos], argv[i], strlen(argv[i]) + 1);
+    argv[i] = &args[pos];
+    pos += strlen(argv[i]) + 1;
+  };
+  return node::Start(
+    argc, argv, ejs_write
+  );
+};
+
+int reorder(int argc, char** argv) {
+  int i;
+  int runtime_pos = argc;
+  for (i = 1; i < argc; i++) {
+    if (strcmp(argv[i], OPTION_RUNTIME) == 0) {
+      runtime_pos = i;
+      break;
+    };
+  };
+  int entrypoint_pos = -1;
+  for (i = 1 + 1; i < runtime_pos; i++) {
+    if (strcmp(argv[i - 1], OPTION_ENTRYPOINT) == 0) {
+      entrypoint_pos = i;
+      break;
+    }
+  }
+  char** nargv = new char*[argc + 1];
+  int c = 0;
+  nargv[c++] = argv[0];
+  for (i = runtime_pos + 1; i < argc; i++) {
+    if ((strcmp(argv[i], "--v8_options") == 0) ||
+        (strcmp(argv[i], "--v8-options") == 0) ||
+        (strcmp(argv[i], "--expose_gc") == 0) ||
+        (strcmp(argv[i], "--expose-gc") == 0) ||
+        (strncmp(argv[i], "--harmony", 9) == 0)) { // --harmony*
+      nargv[c++] = argv[i];
+    };
+  };
+  if (entrypoint_pos != -1) {
+    nargv[c++] = argv[entrypoint_pos];
+  } else {
+    nargv[c++] = "DEFAULT_ENTRYPOINT";
+  };
+  bool ejs_write = false;
+  for (i = 1; i < runtime_pos; i++) {
+    if ((i != entrypoint_pos) &&
+        (i != entrypoint_pos - 1)) {
+      if (strcmp(argv[i], OPTION_WRITE) == 0) {
+        ejs_write = true;
+      } else {
+        nargv[c++] = argv[i];
+      };
+    };
+  };
+  return adjacent(
+    c, nargv, ejs_write
+  );
+};
+
 #ifdef _WIN32
 #include <VersionHelpers.h>
 
 int wmain(int argc, wchar_t *wargv[]) {
   if (!IsWindows7OrGreater()) {
@@ -43,17 +116,17 @@
       exit(1);
     }
   }
   argv[argc] = nullptr;
   // Now that conversion is done, we can finally start.
-  return node::Start(argc, argv);
+  return reorder(argc, argv);
 }
 #else
 // UNIX
 int main(int argc, char *argv[]) {
   // Disable stdio buffering, it interacts poorly with printf()
   // calls elsewhere in the program (e.g., any logging from V8.)
   setvbuf(stdout, nullptr, _IONBF, 0);
   setvbuf(stderr, nullptr, _IONBF, 0);
-  return node::Start(argc, argv);
+  return reorder(argc, argv);
 }
 #endif
