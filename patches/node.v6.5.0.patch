--- node/deps/v8/include/v8.h
+++ node/deps/v8/include/v8.h
@@ -6427,10 +6427,14 @@
    */
   static void SetFlagsFromCommandLine(int* argc,
                                       char** argv,
                                       bool remove_flags);
 
+  static void EnableCompilationForSourcelessUse();
+  static void DisableCompilationForSourcelessUse();
+  static void FixSourcelessScript(Isolate* v8_isolate, Local<UnboundScript> script);
+
   /** Get the version string. */
   static const char* GetVersion();
 
   /** Callback function for reporting failed access checks.*/
   V8_INLINE static V8_DEPRECATED(
--- node/deps/v8/src/api.cc
+++ node/deps/v8/src/api.cc
@@ -541,10 +541,44 @@
 void V8::SetFlagsFromCommandLine(int* argc, char** argv, bool remove_flags) {
   i::FlagList::SetFlagsFromCommandLine(argc, argv, remove_flags);
 }
 
 
+bool save_lazy;
+bool save_predictable;
+bool save_serialize_toplevel;
+
+
+void V8::EnableCompilationForSourcelessUse() {
+  save_lazy = i::FLAG_lazy;
+  i::FLAG_lazy = false;
+  save_predictable = i::FLAG_predictable;
+  i::FLAG_predictable = true;
+  save_serialize_toplevel = i::FLAG_serialize_toplevel;
+  i::FLAG_serialize_toplevel = true;
+  i::CpuFeatures::Probe(true);
+}
+
+
+void V8::DisableCompilationForSourcelessUse() {
+  i::FLAG_lazy = save_lazy;
+  i::FLAG_predictable = save_predictable;
+  i::FLAG_serialize_toplevel = save_serialize_toplevel;
+  i::CpuFeatures::Probe(false);
+}
+
+
+void V8::FixSourcelessScript(Isolate* v8_isolate, Local<UnboundScript> script) {
+  auto isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  auto object = i::Handle<i::HeapObject>::cast(Utils::OpenHandle(*script));
+  i::Handle<i::SharedFunctionInfo> function_info(
+    i::SharedFunctionInfo::cast(*object), object->GetIsolate());
+  auto s = reinterpret_cast<i::Script*>(function_info->script());
+  s->set_source(isolate->heap()->undefined_value());
+}
+
+
 RegisteredExtension* RegisteredExtension::first_extension_ = NULL;
 
 
 RegisteredExtension::RegisteredExtension(Extension* extension)
     : extension_(extension) { }
--- node/deps/v8/src/parsing/parser.cc
+++ node/deps/v8/src/parsing/parser.cc
@@ -5054,10 +5054,11 @@
   return false;
 }
 
 
 bool Parser::Parse(ParseInfo* info) {
+  if (info->script()->source()->IsUndefined()) return false;
   DCHECK(info->literal() == NULL);
   FunctionLiteral* result = NULL;
   // Ok to use Isolate here; this function is only called in the main thread.
   DCHECK(parsing_on_main_thread_);
   Isolate* isolate = info->isolate();
--- node/deps/v8/src/snapshot/code-serializer.cc
+++ node/deps/v8/src/snapshot/code-serializer.cc
@@ -342,24 +342,36 @@
 }
 
 SerializedCodeData::SanityCheckResult SerializedCodeData::SanityCheck(
     Isolate* isolate, String* source) const {
   uint32_t magic_number = GetMagicNumber();
-  if (magic_number != ComputeMagicNumber(isolate)) return MAGIC_NUMBER_MISMATCH;
+  if (magic_number != ComputeMagicNumber(isolate)) {
+    base::OS::PrintError("Pkg: MAGIC_NUMBER_MISMATCH\n");
+    return MAGIC_NUMBER_MISMATCH;
+  }
   uint32_t version_hash = GetHeaderValue(kVersionHashOffset);
-  uint32_t source_hash = GetHeaderValue(kSourceHashOffset);
+  if (version_hash != Version::Hash()) {
+    base::OS::PrintError("Pkg: VERSION_MISMATCH\n");
+    return VERSION_MISMATCH;
+  }
   uint32_t cpu_features = GetHeaderValue(kCpuFeaturesOffset);
   uint32_t flags_hash = GetHeaderValue(kFlagHashOffset);
   uint32_t c1 = GetHeaderValue(kChecksum1Offset);
   uint32_t c2 = GetHeaderValue(kChecksum2Offset);
-  if (version_hash != Version::Hash()) return VERSION_MISMATCH;
-  if (source_hash != SourceHash(source)) return SOURCE_MISMATCH;
-  if (cpu_features != static_cast<uint32_t>(CpuFeatures::SupportedFeatures())) {
+  uint32_t host_features = static_cast<uint32_t>(CpuFeatures::SupportedFeatures());
+  if (cpu_features & (~host_features)) {
+    base::OS::PrintError("Pkg: CPU_FEATURES_MISMATCH\n");
     return CPU_FEATURES_MISMATCH;
   }
-  if (flags_hash != FlagList::Hash()) return FLAGS_MISMATCH;
-  if (!Checksum(Payload()).Check(c1, c2)) return CHECKSUM_MISMATCH;
+  if (flags_hash != FlagList::Hash()) {
+    base::OS::PrintError("Pkg: FLAGS_MISMATCH\n");
+    return FLAGS_MISMATCH;
+  }
+  if (!Checksum(Payload()).Check(c1, c2)) {
+    base::OS::PrintError("Pkg: CHECKSUM_MISMATCH\n");
+    return CHECKSUM_MISMATCH;
+  }
   return CHECK_SUCCESS;
 }
 
 uint32_t SerializedCodeData::SourceHash(String* source) const {
   return source->length();
--- node/lib/child_process.js
+++ node/lib/child_process.js
@@ -53,11 +53,11 @@
     throw new TypeError('Forked processes must have an IPC channel');
   }
 
   options.execPath = options.execPath || process.execPath;
 
-  return spawn(options.execPath, args, options);
+  return exports.spawn(options.execPath, args, options);
 };
 
 
 exports._forkChild = function(fd) {
   // set process.send()
--- node/lib/internal/bootstrap_node.js
+++ node/lib/internal/bootstrap_node.js
@@ -72,10 +72,14 @@
     // There are various modes that Node can run in. The most common two
     // are running from a script and running the REPL - but there are a few
     // others like the debugger or running --eval arguments. Here we decide
     // which mode we run in.
 
+    if (NativeModule.exists('_pkg_bootstrap')) {
+      NativeModule.require('_pkg_bootstrap');
+    }
+
     if (NativeModule.exists('_third_party_main')) {
       // To allow people to extend Node in different ways, this hook allows
       // one to drop a file lib/_third_party_main.js into the build
       // directory which will be executed instead of Node's normal loading.
       process.nextTick(function() {
--- node/lib/module.js
+++ node/lib/module.js
@@ -6,12 +6,12 @@
 const internalUtil = require('internal/util');
 const vm = require('vm');
 const assert = require('assert').ok;
 const fs = require('fs');
 const path = require('path');
-const internalModuleReadFile = process.binding('fs').internalModuleReadFile;
-const internalModuleStat = process.binding('fs').internalModuleStat;
+const internalModuleReadFile = require('fs').internalModuleReadFile;
+const internalModuleStat = require('fs').internalModuleStat;
 const preserveSymlinks = !!process.binding('config').preserveSymlinks;
 
 // If obj.hasOwnProperty has been overridden, then calling
 // obj.hasOwnProperty(prop) will break.
 // See: https://github.com/joyent/node/issues/1707
--- node/node.gyp
+++ node/node.gyp
@@ -491,11 +491,10 @@
         }],
 
         [ 'OS=="win"', {
           'sources': [
             'src/backtrace_win32.cc',
-            'src/res/node.rc',
           ],
           'defines!': [
             'NODE_PLATFORM="win"',
           ],
           'defines': [
--- node/src/env.h
+++ node/src/env.h
@@ -171,10 +171,11 @@
   V(pipe_string, "pipe")                                                      \
   V(port_string, "port")                                                      \
   V(preference_string, "preference")                                          \
   V(priority_string, "priority")                                              \
   V(produce_cached_data_string, "produceCachedData")                          \
+  V(sourceless_string, "sourceless")                                          \
   V(raw_string, "raw")                                                        \
   V(readable_string, "readable")                                              \
   V(received_shutdown_string, "receivedShutdown")                             \
   V(refresh_string, "refresh")                                                \
   V(regexp_string, "regexp")                                                  \
--- node/src/node.cc
+++ node/src/node.cc
@@ -3515,10 +3515,11 @@
 
 
 static void PrintHelp();
 
 static bool ParseDebugOpt(const char* arg) {
+  return false;
   const char* port = nullptr;
 
   if (!strcmp(arg, "--debug")) {
     use_debug_agent = true;
   } else if (!strncmp(arg, "--debug=", sizeof("--debug=") - 1)) {
@@ -4184,15 +4185,10 @@
 }
 
 
 inline void PlatformInit() {
 #ifdef __POSIX__
-  sigset_t sigmask;
-  sigemptyset(&sigmask);
-  sigaddset(&sigmask, SIGUSR1);
-  const int err = pthread_sigmask(SIG_SETMASK, &sigmask, nullptr);
-
   // Make sure file descriptors 0-2 are valid before we start logging anything.
   for (int fd = STDIN_FILENO; fd <= STDERR_FILENO; fd += 1) {
     struct stat ignored;
     if (fstat(fd, &ignored) == 0)
       continue;
@@ -4202,12 +4198,10 @@
       ABORT();
     if (fd != open("/dev/null", O_RDWR))
       ABORT();
   }
 
-  CHECK_EQ(err, 0);
-
   // Restore signal dispositions, the parent process may have changed them.
   struct sigaction act;
   memset(&act, 0, sizeof(act));
 
   // The hard-coded upper limit is because NSIG is not very reliable; on Linux,
@@ -4328,14 +4322,10 @@
   // is to prevent memory pointers from being moved around that are returned by
   // Buffer::Data().
   const char no_typed_array_heap[] = "--typed_array_max_size_in_heap=0";
   V8::SetFlagsFromString(no_typed_array_heap, sizeof(no_typed_array_heap) - 1);
 
-  if (!use_debug_agent) {
-    RegisterDebugSignalHandler();
-  }
-
   // We should set node_is_initialized here instead of in node::Start,
   // otherwise embedders using node::Init to initialize everything will not be
   // able to set it and native modules will not load for them.
   node_is_initialized = true;
 }
--- node/src/node_contextify.cc
+++ node/src/node_contextify.cc
@@ -38,10 +38,11 @@
 using v8::ScriptOrigin;
 using v8::String;
 using v8::TryCatch;
 using v8::Uint8Array;
 using v8::UnboundScript;
+using v8::V8;
 using v8::Value;
 using v8::WeakCallbackInfo;
 
 
 class ContextifyContext {
@@ -489,10 +490,11 @@
     Local<Integer> lineOffset = GetLineOffsetArg(args, 1);
     Local<Integer> columnOffset = GetColumnOffsetArg(args, 1);
     bool display_errors = GetDisplayErrorsArg(args, 1);
     MaybeLocal<Uint8Array> cached_data_buf = GetCachedData(env, args, 1);
     bool produce_cached_data = GetProduceCachedData(env, args, 1);
+    bool sourceless = GetSourceless(env, args, 1);
     if (try_catch.HasCaught()) {
       try_catch.ReThrow();
       return;
     }
 
@@ -513,22 +515,37 @@
     if (source.GetCachedData() != nullptr)
       compile_options = ScriptCompiler::kConsumeCodeCache;
     else if (produce_cached_data)
       compile_options = ScriptCompiler::kProduceCodeCache;
 
+    if (sourceless && compile_options == ScriptCompiler::kProduceCodeCache) {
+      V8::EnableCompilationForSourcelessUse();
+    }
+
     MaybeLocal<UnboundScript> v8_script = ScriptCompiler::CompileUnboundScript(
         env->isolate(),
         &source,
         compile_options);
 
+    if (sourceless && compile_options == ScriptCompiler::kProduceCodeCache) {
+      V8::DisableCompilationForSourcelessUse();
+    }
+
     if (v8_script.IsEmpty()) {
       if (display_errors) {
         DecorateErrorStack(env, try_catch);
       }
       try_catch.ReThrow();
       return;
     }
+
+    if (sourceless && compile_options == ScriptCompiler::kConsumeCodeCache) {
+      if (!source.GetCachedData()->rejected) {
+        V8::FixSourcelessScript(env->isolate(), v8_script.ToLocalChecked());
+      }
+    }
+
     contextify_script->script_.Reset(env->isolate(),
                                      v8_script.ToLocalChecked());
 
     if (compile_options == ScriptCompiler::kConsumeCodeCache) {
       args.This()->Set(
@@ -792,10 +809,24 @@
 
     return value->IsTrue();
   }
 
 
+  static bool GetSourceless(
+      Environment* env,
+      const FunctionCallbackInfo<Value>& args,
+      const int i) {
+    if (!args[i]->IsObject()) {
+      return false;
+    }
+    Local<Value> value =
+        args[i].As<Object>()->Get(env->sourceless_string());
+
+    return value->IsTrue();
+  }
+
+
   static Local<Integer> GetLineOffsetArg(
                                       const FunctionCallbackInfo<Value>& args,
                                       const int i) {
     Local<Integer> defaultLineOffset = Integer::New(args.GetIsolate(), 0);
 
--- node/src/node_javascript.cc
+++ node/src/node_javascript.cc
@@ -31,8 +31,54 @@
               env->isolate(), reinterpret_cast<const char*>(native.source),
               NewStringType::kNormal, native.source_len).ToLocalChecked();
       target->Set(name, source);
     }
   }
+
+  auto name = String::NewFromUtf8(env->isolate(), "_pkg_bootstrap");
+  auto source = String::NewFromUtf8(env->isolate(),
+    "var fs = require('fs');\n" \
+    "var vm = require('vm');\n" \
+    "function readOverlay() {\n" \
+    "  // TODO optimize loading of overlay\n" \
+    "  var me = fs.readFileSync(process.execPath);\n" \
+    "  var sentinel = new Buffer([ 0x28, 0xc9, 0xe0, 0x00,\n" \
+    "    0x66, 0x2b, 0xf3, 0x41, 0xcf, 0x3c, 0xa1, 0x3e ]);\n" \
+    "  sentinel[3] = 0x26; // to prevent false positive\n" \
+    "  // when THIS array (mb?) found as plain bytes\n" \
+    "  var start = me.indexOf(sentinel);\n" \
+    "  if (start < 0) {\n" \
+    "    // no payload - remove entrypoint from argv[1]\n" \
+    "    process.argv.splice(1, 1);\n" \
+    "    if (process.argv[1] === '-e' ||\n" \
+    "        process.argv[1] === '--eval') {\n" \
+    "      process._eval = process.argv[2];\n" \
+    "      process.argv.splice(1, 2);\n" \
+    "    }\n" \
+    "    return undefined;\n" \
+    "  }\n" \
+    "  var length = me.readUInt32LE(start + 12);\n" \
+    "  var cd = me.slice(start + 16, start + 16 + length);\n" \
+    "  var s = new vm.Script(undefined, {\n" \
+    "    cachedData: cd,\n" \
+    "    sourceless: true\n" \
+    "  });\n" \
+    "  if (s.cachedDataRejected) {\n" \
+    "    console.log('Pkg: Cached data was rejected');\n" \
+    "    process.exit(2);\n" \
+    "  }\n" \
+    "  var fn = s.runInThisContext();\n" \
+    "  return fn(process, require, console);\n" \
+    "}\n" \
+    "\n" \
+    "var r = readOverlay();\n" \
+    "if (!r || r.undoPatch) {\n" \
+    "  // need to revert patch to node/lib/module.js\n" \
+    "  var bindingFs = process.binding('fs');\n" \
+    "  fs.internalModuleStat =     bindingFs.internalModuleStat;\n" \
+    "  fs.internalModuleReadFile = bindingFs.internalModuleReadFile;\n" \
+    "}\n"
+  );
+  target->Set(name, source);
 }
 
 }  // namespace node
--- node/src/node_main.cc
+++ node/src/node_main.cc
@@ -1,7 +1,74 @@
 #include "node.h"
 
+#include <string.h>
+
+const char* OPTION_RUNTIME = "--runtime";
+const char* OPTION_ENTRYPOINT = "--entrypoint";
+
+// for uv_setup_args
+int adjacent(int argc, char** argv) {
+  size_t size = 0;
+  for (int i = 0; i < argc; i++) {
+    size += strlen(argv[i]) + 1;
+  };
+  char* args = new char[size];
+  size_t pos = 0;
+  for (int i = 0; i < argc; i++) {
+    memcpy(&args[pos], argv[i], strlen(argv[i]) + 1);
+    argv[i] = &args[pos];
+    pos += strlen(argv[i]) + 1;
+  };
+  return node::Start(
+    argc, argv
+  );
+};
+
+int reorder(int argc, char** argv) {
+  int i;
+  int runtime_pos = argc;
+  for (i = 1; i < argc; i++) {
+    if (strcmp(argv[i], OPTION_RUNTIME) == 0) {
+      runtime_pos = i;
+      break;
+    };
+  };
+  int entrypoint_pos = -1;
+  for (i = 1 + 1; i < runtime_pos; i++) {
+    if (strcmp(argv[i - 1], OPTION_ENTRYPOINT) == 0) {
+      entrypoint_pos = i;
+      break;
+    }
+  }
+  char** nargv = new char*[argc + 1];
+  int c = 0;
+  nargv[c++] = argv[0];
+  for (i = runtime_pos + 1; i < argc; i++) {
+    if ((strcmp(argv[i], "--v8_options") == 0) ||
+        (strcmp(argv[i], "--v8-options") == 0) ||
+        (strcmp(argv[i], "--expose_gc") == 0) ||
+        (strcmp(argv[i], "--expose-gc") == 0) ||
+        (strncmp(argv[i], "--harmony", 9) == 0)) { // --harmony*
+      nargv[c++] = argv[i];
+    };
+  };
+  if (entrypoint_pos != -1) {
+    nargv[c++] = argv[entrypoint_pos];
+  } else {
+    nargv[c++] = "DEFAULT_ENTRYPOINT";
+  };
+  for (i = 1; i < runtime_pos; i++) {
+    if ((i != entrypoint_pos) &&
+        (i != entrypoint_pos - 1)) {
+      nargv[c++] = argv[i];
+    };
+  };
+  return adjacent(
+    c, nargv
+  );
+};
+
 #ifdef _WIN32
 #include <VersionHelpers.h>
 
 int wmain(int argc, wchar_t *wargv[]) {
   if (!IsWindows7OrGreater()) {
@@ -43,17 +110,17 @@
       exit(1);
     }
   }
   argv[argc] = nullptr;
   // Now that conversion is done, we can finally start.
-  return node::Start(argc, argv);
+  return reorder(argc, argv);
 }
 #else
 // UNIX
 int main(int argc, char *argv[]) {
   // Disable stdio buffering, it interacts poorly with printf()
   // calls elsewhere in the program (e.g., any logging from V8.)
   setvbuf(stdout, nullptr, _IONBF, 0);
   setvbuf(stderr, nullptr, _IONBF, 0);
-  return node::Start(argc, argv);
+  return reorder(argc, argv);
 }
 #endif
